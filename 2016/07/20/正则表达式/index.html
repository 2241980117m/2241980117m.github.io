<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>正则表达式 | Carrie博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Carrie,前端,用户体验,nodejs,JavaScript" />
  

  <meta name="description" content="正则表达式是用来进行文本匹配的工具。 正则表达式的匹配模式支持下列3个标志：   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.g:表示全局模式。应用于所有字符串。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.i:表示不区分大小写。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.m:表示多行模式。在达到文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。 正则表达">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="http://yoursite.com/2016/07/20/正则表达式/index.html">
<meta property="og:site_name" content="Carrie博客">
<meta property="og:description" content="正则表达式是用来进行文本匹配的工具。 正则表达式的匹配模式支持下列3个标志：   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.g:表示全局模式。应用于所有字符串。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.i:表示不区分大小写。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.m:表示多行模式。在达到文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。 正则表达">
<meta property="og:updated_time" content="2017-05-11T13:59:38.963Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正则表达式">
<meta name="twitter:description" content="正则表达式是用来进行文本匹配的工具。 正则表达式的匹配模式支持下列3个标志：   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.g:表示全局模式。应用于所有字符串。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.i:表示不区分大小写。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.m:表示多行模式。在达到文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。 正则表达">

  

  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">全部</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">全部</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">正则表达式是用来进行文本匹配的工具。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">正则表达式的匹配模式支持下列3个标志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">正则表达式常用的元字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">定义正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">RegExp实例属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">RegExp实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">RegExp构造函数属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">前后查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">贪婪型和懒惰型</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-正则表达式" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">正则表达式</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.07.20</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Carrie</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <ul>
<li><h2>正则表达式是用来进行文本匹配的工具。</h2></li>
<li><h2>正则表达式的匹配模式支持下列3个标志：</h2><br>   &nbsp;&nbsp;&nbsp;&nbsp;1.g:表示全局模式。应用于所有字符串。<br>   &nbsp;&nbsp;&nbsp;&nbsp;2.i:表示不区分大小写。<br>   &nbsp;&nbsp;&nbsp;&nbsp;3.m:表示多行模式。在达到文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。</li>
<li><h2>正则表达式常用的元字符</h2><br>  &nbsp;&nbsp;&nbsp;&nbsp;1.\b:代表单词的开头或末尾，只匹配一个位置。<br>  &nbsp;&nbsp;&nbsp;&nbsp;2.\d:匹配一个数字。<br>  &nbsp;&nbsp;&nbsp;&nbsp;3..:匹配换行符以外的任意字符<br>  &nbsp;&nbsp;&nbsp;&nbsp;4.*：重复次数，至少0次<br>  &nbsp;&nbsp;&nbsp;&nbsp;5.+：重复次数，至少1次<br>  &nbsp;&nbsp;&nbsp;&nbsp;6.? 表示匹配0次或者1次<br>  &nbsp;&nbsp;&nbsp;&nbsp;7.\s:匹配任何不可见的字符（制表符，换页符）<br>  &nbsp;&nbsp;&nbsp;&nbsp;8.\w:匹配任何非单词的字符（字母，数字，_）<br>  &nbsp;&nbsp;&nbsp;&nbsp;9.^:字符串的开头<br>  &nbsp;&nbsp;&nbsp;&nbsp;10.$：字符串的结束<br>  &nbsp;&nbsp;&nbsp;&nbsp;11.{n,m}:(n&lt;=m) 最少n次，最多m次<br>  &nbsp;&nbsp;&nbsp;&nbsp;12.[n-m]:匹配指定范围内的任意字符<br> &nbsp;&nbsp;&nbsp;&nbsp;13.（）: 用来将复杂的正则表达式分解为多个简单的子表达式。</li>
<li><b>注意：模式中所有使用的元字符都必须转义，在[]中元字符可以不用转义；</b></li>
<li><h2>定义正则表达式</h2><br>定义正则表达式有2中方法，分别是：字面量形式，RegExp构造函数<br>两者的区别是：正则表达式字面量会共享同一个实例，而用RegExp构造的每一个实例都是一个新实例。如：<br>字面量形式<pre><code>var a=/.at/g;    //匹配所有的以at结尾的3字符的字符串
</code></pre>RegExp构造函数<pre><code>var b=new RegExp(&quot;.at&quot;,&quot;g&quot;)
</code></pre>   a和b是完全等价的，使用RegExp构造函数定义正则表达式，接收2个参数，这两个参数必须是字符串形式，<br>   且2个参数分别是：匹配的模式，匹配模式的标志。而在字面量中转义的元字符必须在RegExp构造函数中<br>   双重转义。</li>
<li><h2>RegExp实例属性</h2><br>每个实例都会具有以下属性，通过他们可以获得正则表达式的相关信息<br>  1.global：布尔值，正则表达式是否设定了g标志<br>  2.ignoreCase:布尔值，正则表达式是否设定了i标志<br>  3.multiline:布尔值，正则表达式是否设定了m标志<br>  4.source: 返回正则表达式的字符串表示。按照字面量的形式返回。<br>  5.lastIndex:整数，表示搜索下一个匹配项的字符位置，从0算起</li>
<li><h2>RegExp实例方法</h2><br>1.<b>exec():</b> 接收1个参数，它是应用模式的字符串。返回的是一个数组，数组的第一项是与模式匹配的项，<br>其他的是与捕获组匹配的字符串。这个数组具有2个属性，分别是:index(匹配项在数组中的位置)，input<br>(应用正则表达式的字符串)。如果匹配模式是全局模式，则每次在字符串数组中继续查找匹配项，且lastIndex每次都不同<br>若没有全局标志，则每次返回第一个匹配项的信息。且lastIndex每次为0.<br>2.<b>test():</b>接收一个参数，它是应用匹配模式的字符串。若字符串与模式匹配返回true，否则返回false.<br>3.<b>toLocalString(),toString():</b> 返回正则表达式的字面量。与定义正则表达式的方式无关。<br>4.<b>valueOf():</b>返回正则表达式本身。</li>
<li><p></p><h2>RegExp构造函数属性</h2><br>可以通过两种方法访问这些属性，即常属性法和短属性法。短属性法除了input外其他都不符合ES的标识符，<br>可以通过[]来访问.<br>  1.input($_):返回最近一次应用于匹配模式的字符串<br>  2.lastMatch($&amp;):最近一次的匹配项<br>  3.lastParen($+):最近一次的捕获组<br>  4.leftContent($`):input字符串中lastMatch之前的文本<br>  5.rightContent($’):input字符串中lastMatch之后的文本<br>  6.multiline($*):布尔值，所有表达式是否是否使用多行模式<br>  此外，还具有9个用于存储捕获组的属性，即RegExp.$1,RegExp.$2…<br>  <b>$1和\1表示匹配的第一个正则子表达式，常用在回溯引用中。</b><p></p>
 <hr>
</li>
<li><p></p><h2>前后查找</h2><br>  <b>作用：前后查找都可以做到根据一个条件来筛选出一段文本，但筛选出的文本中不包含筛选条件。</b><br>  向前查找<p></p>
<pre><code>任何表达式都可以转化为向前查找表达式，只需要在它之前加上?=前缀即可。
</code></pre><p>  向后查找</p>
<pre><code>向后查找表达式只需要加上?&lt;=前缀即可。
</code></pre><p>  负向前查找</p>
<pre><code>负向前查找是匹配不与指定模式相匹配的文本。类似于向前查找。应该使用?!前缀。
</code></pre><p>  负向后查找</p>
<pre><code>负向后查找类似于向后查找，匹配不与给定模式相匹配的文本。应该使用?&lt;!前缀。
</code></pre><p>  <b>在前后查找表达式中，如果根据元字符进行前后查找，则该元字符需要转义。前后查找一般与()配合使用。</b></p>
</li>
<li><h2>贪婪型和懒惰型</h2><br>   <b>在正则表达式中，存在贪婪型和懒惰型两种方式，我们可以根据自身需求选择性使用</b><br>  以下例子均使用<br>   <code>var str=&quot;&lt;h1&gt;hello world!&lt;/h1&gt;&lt;h1&gt;Do you want to go shopping.&lt;/h1&gt;&quot;</code><br>   <code>var pattern=&quot;&lt;h1&gt;.*&lt;/h1&gt;&quot;</code><br>  贪婪型<pre><code>得到的结果是 &quot;&lt;h1&gt;hello world!&lt;/h1&gt;&lt;h1&gt;Do you want to go shopping.&lt;/h1&gt;&quot;
</code></pre>  懒惰型<pre><code>得到的结果是 &quot;&lt;h1&gt;hello world!&lt;/h1&gt;&quot;
</code></pre> 如何将贪婪型改为懒惰型<pre><code>只需要将 &quot;var pattern=&apos;&lt;h1&gt;.*&lt;/h1&gt;&apos;  改为 &apos;&lt;h1&gt;.*?&lt;/h1&gt;&apos;&quot;
</code></pre>  <b>总结: 其实实现正则表达式匹配指定字符很简单，困难的是我们需要筛选出那些不需要的字符，所以在使用正则表达式时一定要考虑周到。</b>  <hr>
</li>
</ul>

    
  </div>
</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2016/07/20/JS的引用类型及其方法-1/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2016/07/22/如何获取html元素的css样式/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
