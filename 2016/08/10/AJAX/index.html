<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Ajax | Carrie博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Carrie,前端,用户体验,nodejs,JavaScript" />
  

  <meta name="description" content="简介AJAX（异步的JavaScript和XML）不是一种语言，而是一种使用现有标准的新方法，在不更新页面的情况下，实现和服务器交换数据并动态更新网页。它的核心是XHR对象。 XHR对象创建XHR对象      var xhr=new XMLHttpRequest();      XHR对象拥有2个方法，4个属性。以下将分别讲解。方法  open()它接收3个参数,分别是请求方法，请求URL，是否">
<meta property="og:type" content="article">
<meta property="og:title" content="Ajax">
<meta property="og:url" content="http://yoursite.com/2016/08/10/AJAX/index.html">
<meta property="og:site_name" content="Carrie博客">
<meta property="og:description" content="简介AJAX（异步的JavaScript和XML）不是一种语言，而是一种使用现有标准的新方法，在不更新页面的情况下，实现和服务器交换数据并动态更新网页。它的核心是XHR对象。 XHR对象创建XHR对象      var xhr=new XMLHttpRequest();      XHR对象拥有2个方法，4个属性。以下将分别讲解。方法  open()它接收3个参数,分别是请求方法，请求URL，是否">
<meta property="og:updated_time" content="2017-12-09T04:22:14.964Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ajax">
<meta name="twitter:description" content="简介AJAX（异步的JavaScript和XML）不是一种语言，而是一种使用现有标准的新方法，在不更新页面的情况下，实现和服务器交换数据并动态更新网页。它的核心是XHR对象。 XHR对象创建XHR对象      var xhr=new XMLHttpRequest();      XHR对象拥有2个方法，4个属性。以下将分别讲解。方法  open()它接收3个参数,分别是请求方法，请求URL，是否">

  

  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">全部</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">全部</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">XHR对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">HTTP头部信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">FormData类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">超时设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">overrideMIMEType()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">进度事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">跨源资源共享</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-AJAX" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Ajax</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.08.10</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Carrie</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p></p><h2>简介</h2><br>AJAX（异步的JavaScript和XML）不是一种语言，而是一种使用现有标准的新方法，在不更新页面的情况下，实现和服务器交换数据并动态更新网页。它的核心是XHR对象。<p></p>
<p></p><h2>XHR对象</h2><br><b>创建XHR对象</b><br>      var xhr=new XMLHttpRequest();<br>      XHR对象拥有2个方法，4个属性。以下将分别讲解。<br><b>方法</b><p></p>
<ul>
<li>open()<br>它接收3个参数,分别是请求方法，请求URL，是否异步处理。但是open()并不是真正发送请求，仅是启动一个请求以备发送。</li>
<li>send()<br>它接收参数，即作为主体要发送的数据，没有要发送的数据时，为避免出错参数为null.<br><strong>属性</strong></li>
<li>responseText<br>被返回的文本，无论返回的内容类型是什么，返回的文本都会存在这里。</li>
<li>responseXML<br>当返回的文本内容类型为XML时，返回的文本将会保存在这里。</li>
<li>status<br>响应的HTTP状态（HTTP状态代码为200时，表示响应成功;HTTP状态代码为304时，表示请求的资源没有改变。）</li>
<li>statusText<br>HTTP状态说明<br><strong>是否异步处理</strong><br>当open()的第三个参数为false时，表示同步处理（js代码会等到服务器响应之后再继续执行），<br>收到响应后，响应内容被保存在XHR的属性中。<br>当open()的第三个参数为true时，表示异步处理（js代码继续执行，不用等待响应），此时应该检测readyState属性。<br>readyState的值和代表含义如下 :<br>0 —— 没有调用open();<br>1 —— 调用open(),没有调用send();<br>2 —— 调用send(),没有收到响<br>3 —— 已经接收到部分响应数据<br>4 —— 已经接收到全部的响应数据<br>当readyState的值改变时，会触发onreadystatechange事件。不过在调用open()之前指定onreadystatechange事件处理程序才能保证跨浏览器兼容性。<br><strong>取消异步处理</strong><br>可以通过调用abort()实现。<br><h2>HTTP头部信息</h2><br><strong>setRequestHeader()</strong><br>可以设置自定义的请求头部信息，接收两个参数,分别是：头部字段的名称，头部字段的值。在open()之后，send()之前调用它<br><strong>getResponseHeader()</strong><br>接收一个参数，即头部字段的名称，返回对应的头部字段的值。<br><strong>getAllResponseHeaders()</strong><br>返回包含所有头部信息的长字符串。<br><h2>请求方法</h2><br><strong>GET</strong><br>用于从服务器查询信息。可以将查询字符串置于URL的末尾。查询字符串每个参数的名称和值都必须是encodeURIComponent()进行编码。<br><strong>POST</strong><br>用于向服务器发送应该被保存的信息，post请求的主体可以包含非常多的数据，格式不限。post请求的第二步就是send()，send()的参数必须是xml文档,文档经序列化以后作为请求主体被提交到服务器。<br>但是,服务器对post请求和web表单请求不会一视同仁，我们就需要程序读取发送过来的数据，提取出有用的部分，可以用XHR模仿表单提交，将Content-Type的头部信息设为application/x-www-form-urlencoded,将表单信息序列化，再通过XHR发送到服务器。<br><h2>FormData类型</h2><br>FormData类型为序列化表单和创建于表单数据格式相同的数据提供了便利。<br><strong>创建FormData对象</strong><br>  var form=new FormData();<br>  form.append(“name”,”a”);<br>append()函数接收两个参数，分别是；对应表单字段的名字和字段中包含的值。<br>也可以向FormData()构造函数中传入表单元素。<br><h2>超时设定</h2><br>仅IE8支持，IE8改XHR对象添加了timeout属性，给timeout属性设置一个值,当响应时间超过这个值时，就会执行ontimeout事件<br><h2>overrideMIMEType()</h2><br>返回响应的MIME类型决定了XHR对象如何处理返回的文本，当MIME为text/plain,但实际上数据是XML，则responseText属性中是null.通过调用overrideMIMEType()可以设置MIME类型。参数是MIME类型<br><h2>进度事件</h2><br>一共有6个进度事件，只在这里讲述其中2个事件。</li>
<li>load事件<br>当响应接收完毕后会触发load事件，用以替代onreadystatechange事件，而onload事件处理程序会接收到event对象，它的target属性会指向XHR对象实例，访问到它的所有属性和方法。</li>
<li>progress事件<br>会在浏览器接收新数据期间周期性的触发，progress事件处理程序会接收event参数,它的target属性指向XHR对象，不过他还有3个额外的属性,分别是:lengthComputable(表示进度信息是否可用),totalSize(预期的字节数),position(已经接收到的字节数).<br><h2>跨源资源共享</h2><br><b>什么是跨域</b><br> <p>请求的url的协议，域名，端口三者任一与当前页面不同即为跨域。</p><br><strong>XDR</strong><br>IE8引入了XDR，与XHR类似，但能实现跨域通信，而XHR只能访问与他的页面位于同一域的资源。且cookie不随请求发送，不随响应返回，不能访问响应头部的信息，<br>只能修改请求头部的Content-Type字段,只支持get和post请求.且所有的XDR请求都是异步执行的。<br><strong>XDR对象的使用方法</strong><br>var xdr=new XDomainRequest();<br>xdr.onload=function(){<br>  alert(xdr.responseText);<br>}<br>xdr.open(“get”,”####”);<br>xdr.send(null);<br><strong>同样,XDR对象也支持timeout属性以及timeout事件处理程序</strong><br>为支持post请求,XDR对象也支持ContentType属性,用来表示发送数据的格式。<br>而其他浏览器只需要将open()中的第二个参数url设为绝对URL即可。跨域XHR同时存在一些限制（为了安全考虑），如；<br>1.不能使用setRequestHeader()设置自定义头部。<br>2.不能发送和调用cookie.<br>3.使用getAllRequestHeaders()返回空字符串。<br><strong>动态创建script标签</strong><br>img标签的src可以实现跨域，script的src也可以实现跨域。如:<br>  var script=document.createElement(“script”);<br>  script.src=”  “; //填写请求的url<br>  document.body.appendChild(script);<br><strong>带凭据的请求</strong><br>一般地，跨域请求不提供凭据(cookie,客户端SSL证明,HTTP认证)，但是通过withCredentials属性设为true,可以指定某个请求发送凭据。如果服务器接收这个请求就会用下面的HTTP头部来响应；Access-Control-Allow-Credentials:true.如果服务器的响应里没有包含这个头部，则浏览器不会把响应交给JS，responseText的值是空字符串。<br><strong>Jquery Ajax</strong><br>通过Jquery Ajax的JSONP实现跨域请求。</li>
</ul>

    
  </div>
</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2016/08/09/JSON/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2016/08/31/css选择器的优先级/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
