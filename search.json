[{"title":"算法之排序算法总结","url":"http://yoursite.com/2018/03/04/paixu/","content":"<p>ps:这里的排序都是从小到大进行排列。</p>\n<p></p><h2>冒泡排序</h2><p></p>\n<ul><br>    <li>算法思想:从第一个数开始，将两个相邻的数进行比较，如果前一个数大于后一个数，则互换位置，否则保持不变。这样比较一趟，可以把最大的数放在末尾(根据循环的趟数决定)。依次循环，直到排序完成。</li><br>    <li>时间复杂度:O(n^2)</li><br>    <li>空间复杂度:O(1)</li><br></ul><br><h2>选择排序</h2><br><ul><br>    <li>算法思想:从待排序的数字中找出最小的数，放在排序数字的最开始，之后依次在未排序的数字中选出最小的数放在已经排序的数字的末尾。</li><br>    <li>时间复杂度:O(n^2)</li><br>    <li>空间复杂度:O(1)</li><br></ul><br><h2>快速排序</h2><br><ul><br>    <li>算法思想:【i表示数组开始下标，j表示数组最后一个元素的下标】可以依赖递归来实现。选取一个基数（可以选取数组的第一个数作为基数），从最后一个数开始遍历，如果小于基数则将该数放在前面（a[i]=a[j,i++)；如果大于基数则将该数放在后面(a[j]=a[i],j++)；直到i==j，循环结束。之后，将开始下标置为0，结束下标置为i-1；开始下标置为i+1,结束下标置为数组长度-1,来实现递归操作。</li><br>    <li>时间复杂度:O(nlogn)</li><br>    <li>空间复杂度:O(1)</li><br></ul><br><h2>基数排序</h2><br><ul><br>    <li>算法思想:首先，决定好需要排序的位数。将所有需要排序的数的每一位分割，根据各位将待排序的数字进行排列，之后根据百位…</li><br>    <li>时间复杂度:O(kn)【n表示个数，k表示位数】</li><br>    <li>空间复杂度:O(r+n)【r表示桶个数】</li><br></ul><br><h2>归并排序</h2><br><ul><br>    <li>算法思想:<br><br>        分解：1.将一个数组分成两个数组。2.循环第一步，直到划分出来的“小数组”只包含一个元素.<br>        归并：1.将两个有序的数组合并到一个大的数组中。2.从最小的只包含一个元素的数组开始两两合并。此时，合并好的数组也是有序的<br>    </li><br>    <li>时间复杂度:O(nlogn)</li><br>    <li>空间复杂度:O(n)</li><br></ul><br><h2>计数排序</h2><br><ul><br>    <li>算法思想:需要临时创建一个数组，该数组的长度由等待排序数据的差决定。将待排序的数与数组的下标相对应，临时数组的值是等待排序的数字中和临时数组下标相等的数据的个数。之后，将临时数组按照数组值将下标一一输出就可完成排序。</li><br>    <li>时间复杂度:O(n)</li><br>    <li>空间复杂度:O(n)</li><br></ul><br><h2>插入排序</h2><br><ul><br>    <li>算法思想:从数字列表中依次选取一个数，与已经排序好的数字从最后一个数开始进行比较，如果准备插入的数小于该数，则将该数往后移一个位置，直到准备插入的数大于或等于该数时，将准备插入的数字放入该数的后面。</li><br>    <li>时间复杂度:O(n^2)</li><br>    <li>空间复杂度:O(1)</li><br></ul>","categories":[],"tags":[]},{"title":"css选择符","url":"http://yoursite.com/2018/02/21/css/","content":"<p></p><p>之前了解过css class选择器、id选择器、标签选择器。但是之后又了解到了一些其他比较实用的css选择器。自己在这里总结一下。因为对刚刚说过的几个选择器已经很了解了，所以就不再讲述了。</p><p></p>\n<p></p><h2>基本选择器</h2><p></p>\n<ul><br><li>class选择器</li><br><li>id选择器</li><br><li>标签选择器</li><br></ul><br><h2>多元素组合的选择器</h2><br><ul><br>    <li>多元素选择器  【如：element,element】</li><br>    <li>后代元素选择器  【如:element element】</li><br>    <li>相邻元素选择器    【如: ele1+ele2,选择的是紧跟在ele1后面的同级子元素】</li><br>    <li>子元素选择器     【如: ele1&gt;ele2,作用类似于element element】</li><br></ul><br><h2>属性选择器</h2><br><ul><br>    <li>ele[attr]:匹配所有具有attr属性的ele元素</li><br>    <li>ele[attr=”<em>“]:匹配所有attr=”</em>“的ele元素</li><br>    <li>ele[attr~=”<em>“]:匹配attr属性等于多个以空格分割的值，其中一个值是</em>的ele元素</li><br>    <li>ele[atrtr|=val]</li><br>    <li>ele[attr^=“val”]:匹配含有attr属性，且值以val打头的ele元素</li><br>    <li>ele[attr$=“val”]:匹配含有attr属性，且值以val结束的ele元素</li><br>    <li>ele[attr*=“val”]:匹配含有attr属性，且值包含“val”字符串的ele元素</li><br></ul><br><h2>伪类选择器</h2><br><ul><br>    <li>ele:first-child:匹配ele是第一个子元素的元素。同样，可以使用:nth-child(),接收的参数可以是数字，公式，关键字。类似的，nth-of-type也是如此</li><br>    <li>ele:lang(c):匹配lang属性等于c的元素</li><br>    <li>ele:not(a):匹配不包含a元素的所有ele元素</li><br></ul><br><h2>伪元素选择器</h2><br><ul><br>    <li>ele:before:在ele之前插入生成的内容，内含有content属性</li><br>    <li>ele:after:在ele之后插入生成的内容，内含有content属性</li><br>    <li>ele:first-line:匹配ele元素的第一行文字</li><br>    <li>ele:first-letter:匹配ele元素的第一个文字</li><br></ul><br><h2>同级元素通用选择器</h2><br><ul><br>    <li>ele1 ~ ele2:匹配ele1之后的所有同级ele2元素</li><br></ul>\n\n","categories":[],"tags":[]},{"title":"css3属性深入","url":"http://yoursite.com/2018/02/20/css3/","content":"<p></p><p>近段时间在看&lt;&lt;css揭秘&gt;&gt;这本书，它注重代码的简洁和可重用性。这本书适合css进阶的时候看，在看这本书时，建议了解一下css、scss。个人还是觉得这本书是不错的。</p><p></p>\n<p></p><p><br>    自己现在只看了前四章，在这里简洁的总结下自己对一些属性的新的理解。<br></p><p></p>\n<p><div></div></p>\n<h3>之前没有了解过的</h3><br><ul><br>    <li>currentColor</li><br>    <li>calc()函数</li><br></ul><br><h3>背景</h3><br><ul><br><li>background-clip:裁剪背景;可以设置为border-box、padding-box、content-box;</li><br><li>background-attachment:设置背景的位置，可以取值为scroll、fixed;</li><br><li>background-position:支持right 20px top 10px;这样的值</li><br><li>background-origin:设置背景起点。取值和background-clip相同;</li><br><li></li><br></ul><br><br><div><br><h3>多重边框</h3><br><p>ps:自己之前实现多重边框时都是用父子div来实现的，但是了解到其它的方法，不得不说真的很方便</p><br><ul><br>    <li>box-shadow:这个属性是用来产生投影的，不会影响布局。参数分别是:水平投影长度，垂直投影长度，模糊距离，扩张半径，向内扩张或者向外扩张（默认向外）。当模糊距离小于或等于负的扩张半径时，投影我们是看不到的。box-shadow可以设置多个值来达到多重边框的效果，但是要注意它会覆盖之前的值，也就是说我们在想要达到两重边框时，需要设置第二个值的扩张半径大于第一个值的扩张半径。</li><br>    <li>outline:取值和border相同，只能设置一个值。</li><br></ul><br> <p>ps:outline、box-shadow的区别是outline不一定紧贴border-radius,而box-shadow紧贴</p><br></div><br><div><br><h3></h3>\n\n<p></p></div><p></p>\n<p><div></div></p>\n<p></p><h3>css渐变</h3><br>  <ul><br>      <li>linear-gradient(线性渐变):参数分别是角度（deg,to bottom right）、起始颜色、起始位置、结束颜色、结束位置。当结束位置为0时，取前面位置的最大值。</li><br>      <li>radial-gradient(垂直渐变)：</li><br>      <li>repeating-linear-gradient:</li><br>      <li>repeating-radial-gradient:</li><br>  </ul><br><p></p>\n<hr>\n","categories":[],"tags":[]},{"title":"web worker","url":"http://yoursite.com/2017/12/09/web-worker/","content":"<p></p><p>web worker则实现了js的多线程。web worker的执行不影响主线程的执行，同时主线程的执行不会影响到web worker线程的执行。当主线程需要进行大量的异步操作或者是大量的计算时，可以考虑使用web worker.</p><p></p>\n<p></p><h2>原理</h2><p></p>\n<p></p><p>主线程通过web worker在后台执行一系列计算或者异步操作，使得主进程能够不发生阻塞情况，带给用户良好的用户体验。</p><p></p>\n<p></p><h2>web worker子线程的局限性</h2><p></p>\n<ul><br>    <li>同域限制</li><br>    <li>DOM限制。子线程不支持全局变量，如:window，document等，但是支持navigator</li><br>    <li>脚本限制。子线程不支持全局方法。比如:alert,confirm</li><br>    <li>文件限制。子线程不支持读取本地文件</li><br></ul><br><h2>分类</h2><br><ul><br>    <li><br>        <h3>只与父进程进行通信的普通worker</h3><br>    </li><br>    <li><br>        <h3>shared worker</h3><br>        <p>可以在多个浏览器下实现数据共享</p><br>    </li><br>    <li><br>        <h3>service worker</h3><br>    <p>前两种都只可以在网页中运行，当网页关闭worker线程关闭。而service worker可以不依赖网页运行。他提供cache API和拦截请求。cache仅在数据删除时，缓存会删除，使用cache API会忽略报文头中的指定是否过期的HTTP信息头。</p><br>    </li><br></ul>","categories":[],"tags":[]},{"title":"node数据库操作及爬虫","url":"http://yoursite.com/2017/08/07/node/","content":"<p></p><p>经过为期1-2的周的学习，总算对node有了大致的理解。因为之前了解过PHP，刚开始学习的时候因为node的异步和底层的东西比较多，所以觉得不怎么好用。但是对于大型网站，node的非阻塞确实还是非常提倡的，毕竟不会导致页面停滞下来，可以很好的完成数据交互。</p><p></p>\n<p></p><p>因为这1-2周的学习比较杂乱，node的各个模块都看了些。在这里就不具体的讲述了，只是分享下mysql数据库操作及node爬虫</p><p></p>\n<p></p><h2>学习建议</h2><br><span>在学习node之前，建议大家先了解js的回调函数、异步、npm及HTTP</span><p></p>\n<p></p><h2>数据库操作</h2><p></p>\n<div><br>      <strong>npm下载mysql模块</strong><br>      <span>npm install mysql</span><br>      <br><br>      <div><br>        <b>数据库的增删改查</b><br>        <span>因为数据库的增删改查只是sql语句不一样，node逻辑相同，因此，只在这里贴出实现数据库查找操作的具体实现.</span><br>        <img src=\"/img/a.png\" style=\"width: 50vw;height: 45vh;\"><br>        <br><br>        <strong>连接池</strong><br>        <span>连接池算是node在数据库方面的特色,因为HP是同步的，在这个方面并没有具体的实现。连接池主要是用来一次性创造多个多个连接，当需要使用的时候直接使用，使用完把连接放回去即可。</span><br>        <strong>具体实现:</strong><br>        <span>创建一个pool.js文件</span><br>        <img src=\"/img/pool.png\" style=\"width: 50vw;height: 58vh;\"><br>        <span>创建pool_node.js文件，引用pool.js实现的接口</span><br>        <img src=\"/img/pool_node.png\" style=\"width: 50vw;height: 20vh;\"><br>        <span>效果展示</span><br>        <img src=\"/img/res1.png\" style=\"width: 50vw;height: 6vh;\"><br>        <br><br>        <strong>注意：之前在网上查看下载mysql模块是npm install mysql@版本号,但是在完成数据库查找时发现报错，去掉后面的版本号就好，即npm install mysql.</strong><br>    </div><br>    <div></div>\n\n<p></p></div><p></p>\n<p></p><h2>node实现爬虫</h2><br><strong>建议:了解cheerio、superagent、express框架</strong><p></p>\n<p></p><h3>express实现爬虫</h3><br><span>爬虫<a href=\"https://cnodejs.org/上面的每个话题标题及跳转的链接地址\" target=\"_blank\" rel=\"external\">https://cnodejs.org/上面的每个话题标题及跳转的链接地址</a></span><br><span>实现</span><br><br><img src=\"/img/express.png\"><br><span style=\"margin-top: 1vh;\">结果</span><br><br><img src=\"/img/res2-1.png\"><p></p>\n<p></p><h3>eventproxy</h3><br><span>爬虫<a href=\"https://cnodejs.org/上面的每个话题标题及第一个评论\" target=\"_blank\" rel=\"external\">https://cnodejs.org/上面的每个话题标题及第一个评论</a></span><br><span>实现</span><br><br><img src=\"/img/event-1.png\"><br><img src=\"/img/event-2.png\"><p></p>\n<p></p><h3>async</h3><br><span>爬虫<a href=\"https://cnodejs.org/上面的每个话题标题及第一个评论\" target=\"_blank\" rel=\"external\">https://cnodejs.org/上面的每个话题标题及第一个评论</a></span><br><span>实现</span><br><br><img src=\"/img/async1.png\"><br><br><img src=\"/img/async1.png\"><br><br><br><span>eventproxy和async实现的爬虫结果截图，仅是一部分</span><br><br><img src=\"/img/res5-1.png\"><br><img src=\"/img/res5-2.png\"><p></p>\n<p><b>eventproxy和async都是流程控制工具，但是async相较于eventproxy，可以控制并发个数，防止请求网站时因为并发量大，而导致IP被封</b></p>\n<p></p><h3>上面例子踩过的坑</h3><p></p>\n<ol>\n<li>eventproxy.after(‘thingname’,times,callback(lists))，其中lists为数组，它是经过times次事件名为thingname的事件传递进来的各个参数所形成的数组。</li>\n<li>async.mapLimit(urlArr,limit,function A(){},function B(){}).其中urlArr为数组，限制并发量为limit,它的每一个元素都要作为A函数的参数进行操作，当A执行完后开始执行B函数，但是A函数中的callback函数的第一个参数只有为null时，才会遍历完整个urlArr.自己对其理解为A函数中的callback函数的参数作为B函数的实参进行调用。</li>\n</ol>\n","categories":[],"tags":[]},{"title":"实现web存储的几种方式","url":"http://yoursite.com/2017/06/02/web/","content":"<p></p><h2>Storage类型</h2><p></p>\n<p>    Storage类型提供了以下几种方法:</p><br>- setItem():设置键值对<br>- getItem():读取指定的元素<br>- clear():清除所有值<br>- removeItem():删除指定的元素<br><br>其中,Storage类型的值可以通过.或者[]访问到。<br><h2>localStorage</h2><br><p>localStorage不会指定任何的访问规则，因为他已经指定好了。在相同的域名(子域名无效)、端口、协议下访问。相当于globalStorage[location.host].它和sessionStorage相同，只保存特定于某个会话的内容。生命周期是截止到调用clear方法，否则一直存在</p><br><h2>globalStorage</h2><br><p>可以实现跨越会话存储数据。需要指定哪些域可以访问该数据，可以通过方括号标记使用属性来实现.共享的数据限制在相同域名，端口，协议下使用，且它保存的数据存储在磁盘里</p><br><h2>sessionStorage</h2><br><p>只适合于存储特定会话内容。即只允许在生成它的页面访问，对多页面应用有限制。</p><br><h2>Cookie</h2><br><p>可以通过document.cookie=decodeURIComponent(“name”)+decodeURIComponent(“value”)来设置。在读取的时候使用decodeURIComponent来解码。在必要时需要设置Domain,path,secure值。cookie不安全，且浏览器会对cookie的数目和长度进行限制。但是子cookie会适当解决cookie数量的限制问题。并且在相同的协议，主机，端口下，cookie会被默认发送，从而影响网站的性能</p>","categories":[],"tags":[]},{"title":"web实现的数据在两个页面之间传递","url":"http://yoursite.com/2017/06/02/two-page-convery-data/","content":"<p></p><p>在平时练习中我们经常会用到数据在两个页面之间传递，比如博客登陆成功后，需要拥有权限去写博客，而为了防止大家直接跳到某个页面执行相同的操作，我们需要在登陆成功后做一个标记，而第二个页面有这个标记时，才会赋予用户权限。</p><p></p>\n<p></p><p>常见的数据在两个页面中传递的方式有以下几种:</p><p></p>\n<ul><br>    <li><br>        <h2>session</h2><br>        <p>牵扯到后台，要用session来做的话，注意如果跨域的话，需要设置withCredentials:true.</p><br>    </li><br>    <li><br>        <h2>window对象</h2><br>        <p>window代表的是打开的窗口或者frame，当两个页面在同一个窗口中展示的话，可以通过window对象来传递数据</p><br>    </li><br>    <li><br>        <h2>cookie</h2><br>        <p>可以在第一个页面设置cookie，在第二个人页面通过字符串方法筛选出传递的值</p><br>    </li><br>    <li><br>        <h2>url</h2><br>        <p>通过url后面的查询字符串来筛选出</p><br>    </li><br>    <li><br>        <h2>隐藏的表单域</h2><br>        <p>通过form表单进行提交,指定action为第二个页面的地址</p><br>    </li><br>    <li><br>        <h2>本地存储</h2><br>        <p>比如：localStorage</p><br>    </li><br>    <li><br>        <h2>windows.postMessage</h2><br>        <p>特点是可以进行跨域传输。传输的数据可以是字符串或者是对象，但是有的浏览器不支持对象传递</p><br>    </li><br><br></ul>\n","categories":[],"tags":[]},{"title":"跨域及服务器发送","url":"http://yoursite.com/2017/05/24/跨域/","content":"<p></p><p>之前在AJAX里说明了下什么是跨域，及使用JSONP和XDR实现跨域通信。但是JSONP局限于只能使用GET方法且需要指定回调函数。在这里，自己再补充下cors实现跨域的方法。</p><p></p>\n<p></p><h2>CORS</h2><p></p>\n<div><br><label for=\"\">不发送cookie</label><br><p>CORS是在服务器端实现跨域的方法，需要设置<code>Access-Control-Allow-Orogin：*</code>，前端代码和HR相同。</p><br></div><br><div><br>    <label for=\"\">发送cookie</label><br>    <p>COOKIE也支持同源策略，如果需要跨域时则需要后台设置响应报文首部字段<code>Access-Control-Allow-Credentials:true</code>及其<code>Access-Control-Allow-Origin</code>,Access-Control-Allow-Origin的值应该和request报文头里的origin字段的值相同。同时前端需要指定withCredentials：true.当请求方法不是POST或者GET,需要后台设置Access-Control-Allow-Methods字段</p><br></div><br>附上<a href=\"\">这里是我浏览的关于CORS实现的文档<br><hr><br><h2>服务器发送技术</h2><br><p>有时我们也需要服务器实时返回数据，虽然我们可以依靠轮询ajax来实现，但是这样的代价会比较大，因为需要客户端定时向服务器发送请求，而请求报文头的内容比较大，会造成网络中的传输量比较大。而web socket解决了这一问题。web socket支持服务器主动向客户端传送数据。而websocket也是建立在TCP连接上，它的第一次握手是依靠HTTP连接完成的，并且他没有同源限制。在web socket方面我服务器端采用了socket.io实现。具体可以看<a href=\"https://github.com/2241980117m/vueItem\" target=\"_blank\" rel=\"external\">socket io实现的聊天室</a></p><br><div><a href=\"http://www.cnblogs.com/vajoy/p/4295825.html#it3\" target=\"_blank\" rel=\"external\">最后附上自己看到的关于实现跨域的文档</a></div><br><div><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">关于web socket一篇不错的文档</a></div>\n</a>","categories":[],"tags":[]},{"title":"ES6 String extension","url":"http://yoursite.com/2017/05/22/ES6-String-extension/","content":"<p>今天看了一下关于ES6的字符串扩展，才对字符串有了进一步的认识。下面就总结下自己的收获。</p><br><h2>字符的表示方法</h2><br><p>以下几种方式可以表示字符’z’</p><br>- \\z<br>- \\x7A<br>- \\172<br>- \\u007A<br>- \\u{7A}<br><br><hr><br><br><p>在这里，我先说一下JS的字符都是2个字节的。Unicode编码超过\\uFFFF的话，用以下的函数会出现不被预料的错误。</p>\n\n\n<p></p><h2>JS支持的字符函数</h2><p></p>\n<ul>\n<li>charAt():根据下标返回对应的字符</li>\n<li>charCodeAt():根据下标返回对应字符的Unicode编码</li>\n<li>fromCharCode():根据Unicode编码返回对应的字符</li>\n<li>for循环:实现对字符串的遍历</li>\n<li>indexOf():返回值是boolean值，用来实现一个字符串里是否包含子字符串。</li>\n</ul>\n<p></p><p>如果字符的Unicode编码超过\\uffff的话，可以使用以下函数：</p><p></p>\n<p></p><h2>ES6支持的字符函数</h2><p></p>\n<ul>\n<li>codePointAt:返回指定下标字符Unicode编码</li>\n<li>fromCodePoint():根据Unicode编码返回对应的字符</li>\n<li>for of : 实现字符串的遍历</li>\n<li>startsWith(str,index): 用来实现从index下标起，字符串以str子字符串开头</li>\n<li>includes(str,index): 用来实现从index下标起，字符串是否包含str子字符串</li>\n<li>endswith(str,index): 用来实现从开始到index下标之间，字符串以str子字符串结束</li>\n<li>repeat(num): 返回num个重复的字符串，向下取整。num为0到-1的话，取值为0</li>\n<li>padStart(length,str): 用str开头来填补字符串，直到字符串的长度为length</li>\n<li>padEnd(length,str): 用str作为结束来填补字符串，直到字符串的长度为length</li>\n</ul>\n<p></p><h2>模板字符串</h2><br>  将字符和变量、对象、函数全部封装在 ``中，实现模板字符串<p></p>\n","categories":[],"tags":[]},{"title":"CSS的float,BFC","url":"http://yoursite.com/2017/05/12/float,position,BFC,文档流/","content":"<p>今天在写网页的时候突然发现给父元素设置text-align:center;子浮动元素不会脱离文档流,百思不得其解。重新看了下关于float的相关知识，就在这里和大家分享一下。</p>\n\n<p></p><h2>float</h2><p></p>\n<ul>\n<li>设置float的元素最后都会生成块级框。即不管设置float的元素是块级元素、行内元素，最后都可以设置width,height属性。</li>\n<li>设置float的元素没有设置width,height属性的话，则该元素会尽可能小的显示。</li>\n<li>设置float的元素会脱离文档流,但是却不会脱离文档流。即其他的布局元素会忽视float元素进行布局，但是文字会认为float元素存在，围绕float元素进行布局。</li>\n<li>设置float元素会默认显示在父元素的paddding之内。</li>\n<li>float元素会脱离文档流,但是当float元素的父元素也设置了float属性，则子元素会包含在父元素里。这就是float的延展性。<br><h2>clear属性</h2><br>clear属性可以取left,right,both值。但是在这里需要注意地点，设置clear的元素只会对其自身的布局有影响。<br><h2>清除浮动</h2><p>清除浮动有2种方法，分别是:</p></li>\n<li>给父元素设置overflow:hidden;</li>\n<li>给最后一个设置float的元素的后面添加一个设置clear:both的元素<br><h2>BFC</h2><p>BFC就是块级格式化上下文。生成BFC的情况有以下几种:</p></li>\n<li>设置float的元素</li>\n<li>position的值为absolute、fixed的元素</li>\n<li>非块级盒子的块级容器</li>\n<li>overflow值不为visiable的元素</li>\n<li>这里推荐一个教程，以便大家更好的了解及应用BFC <a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"external\">BFC深入理解</a><br><hr><br><h2>具体看的资料</h2><br><a href=\"http://www.cnblogs.com/starof/p/4608962.html\" target=\"_blank\" rel=\"external\">深入理解CSS浮动</a><br><a href=\"http://luopq.com/2015/11/08/CSS-float/\" target=\"_blank\" rel=\"external\">详解CSS float</a></li>\n</ul>\n","categories":[],"tags":[]},{"title":"广度优先搜索算法","url":"http://yoursite.com/2016/10/12/广度优先搜索算法/","content":"<p>广度优先搜索算法适用于（树）已知起点和终点，求最短路径问题，它的算法思想如下：<br>从起点出发，寻找四个方向可以走的节点，如果可走则记录下来，开始从起点的下一个结点出发，找上下左右四个方向上下左右可以走的节点，注意不能找重复的点，会造成死循环，而且要注意点的坐标是否符合范围，在记录的过程中应该有一个记录分叉位置的变量，依次这样向下寻找…..当找到终点时结束。此时得到的点的集合不是你想要的最短路径，还包含着其他一些不用的节点，根据记录分叉位置的变量来筛选出最短路径。</p>\n<h2 id=\"具体代码实现如下-迷宫问题\"><a href=\"#具体代码实现如下-迷宫问题\" class=\"headerlink\" title=\"具体代码实现如下(迷宫问题):\"></a>具体代码实现如下(迷宫问题):</h2><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;conio.h&gt;\n#define MAXWIDTH 10\n#define Max 100\n\nstruct iSteps\n{\n    int i;                                    //行号 \n    int j;                                    //列号 \n};\nstruct\n{\n  int i,j;              //块的位置 \n  int pre;              //本路径中上一块在队列中的下标 \n}Qu[Max];\n\nint iMaze[MAXWIDTH][MAXWIDTH];                //存迷宫的数组 \nint rear=-1,front=-1;\n\n/*****函数声明们都放在这里了*****/\nint iRand(int low , int high);\nstruct iSteps loadMaze(int width, struct iSteps firStep);\nint printMaze(int width);\nvoid print(int n) ;\nint mgpath(int xi,int yi,int xe,int ye,int width);\n\n\n/*****这是一个清真的main函数*****/\nint main(void)\n{\n\n    //struct iSteps *head,*p,*q;\n    int high = 10;                            // !important 这里定义了迷宫最大限 \n    int i,j,sum=0;\n    int x,y,x1,y1;\n    int width = iRand(3, high);                //迷宫真正宽度\n    struct iSteps firStep;                    //启点定义 \n\n    firStep = loadMaze(width, firStep);\n    printMaze(width);\n    getch(); \n    for(i=0;i&lt;width;i++){\n    for(j=0;j&lt;width;j++){\n        if(iMaze[i][j]==-1){                                          //得到迷宫的入口坐标\n            x=i;\n            y=j;\n        } \n        if(iMaze[i][j]==6){                                         //得到迷宫的出口坐标\n            x1=i;\n            y1=j;\n        }\n    }\n}\n    getch();\n    printf(&quot;迷宫的入口坐标:%d,%d\\n&quot;,y,x);\n    printf(&quot;迷宫的出口坐标:%d,%d\\n&quot;,y1,x1);\n    getch();\n    mgpath(x,y,x1,y1,width);\n    return 0;\n}\nint mgpath(int xi,int yi,int x,int y,int width)              //广度搜索算法\n{\n    int i,j,find=0,di;\n    rear++;\n    Qu[rear].i=xi;\n    Qu[rear].j=yi;\n    Qu[rear].pre=-1;\n    iMaze[xi][yi]=-1;\n    while(front&lt;=rear&amp;&amp;!find)\n    {\n        front++;\n        i=Qu[front].i;\n        j=Qu[front].j;\n        if(i==x&amp;&amp;j==y)\n        {\n           print(front);\n           return(1);\n        }\n        for(di=0;di&lt;4;di++)\n        {\n           switch(di)              //四个方向 \n           {\n                     case 0:i=Qu[front].i-1;j=Qu[front].j;break;//上\n                     case 1:i=Qu[front].i;j=Qu[front].j+1;break;//右\n                     case 2:i=Qu[front].i+1;j=Qu[front].j;break;//下\n                     case 3:i=Qu[front].i;j=Qu[front].j-1;break;//左\n           }\n           if((iMaze[i][j]==0||iMaze[i][j]==6)&amp;&amp;i&gt;=0&amp;&amp;i&lt;width&amp;&amp;j&gt;=0&amp;&amp;j&lt;width)\n           {\n             rear++;\n             Qu[rear].i=i;\n\n             Qu[rear].j=j;\n             Qu[rear].pre=front;\n             iMaze[i][j]=-1;              //避免死循环 \n           }\n        }\n    }\n    return 0;\n}\n\nvoid print(int n)              //输出 路径算法 \n{\n int k=n,j,m=1;\n printf(&quot;\\n&quot;);\n do              //将输出的最短路径上的所有pre改为-1 即从所有走过的点中选取可以走的最短的路的节点\n {\n    j=k;\n    k=Qu[k].pre;\n    Qu[j].pre=-1;\n }while(k!=0);\n printf(&quot;迷宫最短路径如下：\\n&quot;);\n k=0;\n while(k&lt;Max)\n {\n     //if(Qu[k].pre==-1)\n      //  {\n            printf(&quot;\\t(%d %d)&quot;,Qu[k].j,Qu[k].i);\n            if(m%5==0)\n              printf(&quot;\\n&quot;);\n            m++;\n       // }\n     k++;\n }\n printf(&quot;\\n&quot;);\n}\n/*****定义迷宫少女祈祷中函数*****/\nstruct iSteps loadMaze(int width, struct iSteps firStep)\n{\n    int i, j, temp, t;\n    int stepForward;\n    struct iSteps lastStep;\n    srand(unsigned(time(NULL)));\n    for(i=0; i&lt;width; i++)\n    {\n        for(j=0; j&lt;width; j++)\n        {\n            if(i==0 || j==0 || i==(width-1) || j==(width-1))\n            {\n                iMaze[i][j] = 1;\n            }\n            else\n            {\n                iMaze[i][j] = 2;\n            }\n        }\n    }\ntemp = iRand(0, 3);                        //迷宫启点算法 \nif(temp == 0)\n{\n    t = iRand(1, width-2);\n    iMaze[t][0] = -1;\n    firStep.i = t;\n    firStep.j = 0;\n}\nelse if(temp == 1)\n{\n    t = iRand(1, width-2);\n    iMaze[width-1][t] = -1;\n    firStep.i = width-1;\n    firStep.j = t;\n}\nelse if(temp == 2)\n{\n    t = iRand(1, width-2);\n    iMaze[t][width-1] = -1;\n    firStep.i = t;\n    firStep.j = width-1;\n}\nelse if(temp == 3)\n{\n    t = iRand(1, width-2);\n    iMaze[0][t] = -1;\n    firStep.i = 0;\n    firStep.j = t;\n}\nwhile(1)\n{\n    temp = iRand(0, 3);                        //迷宫终点算法 \n    if(temp == 0)\n    {\n        t = iRand(1, width-2);\n        lastStep.i = t;\n        lastStep.j = 0;\n        if(firStep.i == lastStep.i &amp;&amp; firStep.j == lastStep.j || \n           firStep.i-1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i+1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j+1 == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j-1 == lastStep.j) \n        {\n            continue;\n        }\n        iMaze[t][0] = 6;\n        break;\n    }\n    else if(temp == 1)\n    {\n        t = iRand(1, width-2);\n        lastStep.i = width-1;\n        lastStep.j = t;\n        if(firStep.i == lastStep.i &amp;&amp; firStep.j == lastStep.j || \n           firStep.i-1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i+1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j+1 == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j-1 == lastStep.j) \n        {\n            continue;\n        }\n        iMaze[width-1][t] = 6;\n        break;\n    }\n    else if(temp == 2)\n    {\n        t = iRand(1, width-2);\n        lastStep.i = t;\n        lastStep.j = width-1;\n        if(firStep.i == lastStep.i &amp;&amp; firStep.j == lastStep.j || \n           firStep.i-1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i+1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j+1 == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j-1 == lastStep.j) \n        {\n            continue;\n        }\n        iMaze[t][width-1] = 6;\n        break;\n    }\n    else if(temp == 3)\n    {\n        t = iRand(1, width-2);\n        lastStep.i = 0;\n        lastStep.j = t;\n        if(firStep.i  ==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i-1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i+1==lastStep.i&amp;&amp;firStep.j   == lastStep.j || \n           firStep.i  ==lastStep.i&amp;&amp;firStep.j+1 == lastStep.j ||\n           firStep.i  ==lastStep.i&amp;&amp;firStep.j-1 == lastStep.j) \n        {\n            continue;\n        }\n        iMaze[0][t] = 6;\n        break;\n    }\n}\ni = firStep.i;\nj = firStep.j;\nwhile(1)\n{    \n    stepForward = rand()%4;\n    if(stepForward==0 &amp;&amp; j-1&gt;=0 &amp;&amp; iMaze[i][j-1]!=1 &amp;&amp; iMaze[i][j-1]!=-1)\n    {\n        if(iMaze[i][j-1]==6 || iMaze[i+1][j]==6 || iMaze[i][j+1]==6 || iMaze[i-1][j]==6)\n        {\n            break;\n        }\n        iMaze[i][j-1] = 0;\n        j = j-1;\n    }\n    else if(stepForward==1 &amp;&amp; i+1&lt;width &amp;&amp; iMaze[i+1][j]!=1 &amp;&amp; iMaze[i+1][j]!=-1)\n    {\n        if(iMaze[i][j-1]==6 || iMaze[i+1][j]==6 || iMaze[i][j+1]==6 || iMaze[i-1][j]==6)\n        {\n            break;\n        }\n        iMaze[i+1][j] = 0;\n        i = i+1;\n    }\n    else if(stepForward==2 &amp;&amp; j+1&lt;width &amp;&amp; iMaze[i][j+1]!=1 &amp;&amp; iMaze[i][j+1]!=-1)\n    {\n        if(iMaze[i][j-1]==6 || iMaze[i+1][j]==6 || iMaze[i][j+1]==6 || iMaze[i-1][j]==6)\n        {\n            break;\n        }\n        iMaze[i][j+1] = 0;\n        j = j+1;\n    }\n    else if(stepForward==3 &amp;&amp; i-1&gt;=0 &amp;&amp; iMaze[i-1][j]!=1 &amp;&amp; iMaze[i-1][j]!=-1)\n    {\n        if(iMaze[i][j-1]==6 || iMaze[i+1][j]==6 || iMaze[i][j+1]==6 || iMaze[i-1][j]==6)\n        {\n            break;\n        }\n        iMaze[i-1][j] = 0;\n        i = i-1;\n    }\n}\nfor(i=0; i&lt;width; i++)\n{\n    for(j=0; j&lt;width; j++)\n    {\n        if(iMaze[j][i] == 2)\n        {\n            iMaze[j][i] = 1;\n        } \n    }\n}\nreturn firStep;\n}\n\n/*******用于打印迷宫的函数*******/\nint printMaze(int width)\n{\n    int i, j;\n    for(i=0; i&lt;width; i++)\n    {\n        for(j=0; j&lt;width; j++)\n        {\n            printf(&quot;\\t%d&quot;, iMaze[j][i]);\n        }\n        printf(&quot;\\n\\n\\n&quot;);\n    }\n    return 0;\n}\n\n/*****自定义的随机数生成函数*****/\nint iRand(int low, int high)               //产生low ~ high 间的随机数\n{\n    int base;\n    int iNum;\n    if(low &gt; high)                       //防止参数顺序错误\n    {\n        int t;\n        t = low;\n        low = high; \n        high = t;\n    }\nbase = high-low+1;                   //确定计数的基数\nsrand(unsigned(time(NULL)));\niNum = rand()%base;                 //产生计数器\nreturn (low + iNum);\n</code></pre><p>}  `</p>\n","categories":[],"tags":[]},{"title":"css中关于margin的问题","url":"http://yoursite.com/2016/10/09/css中关于margin的问题/","content":"<p>在讲margin的问题时，应该先了解行内元素和块级元素及可置换元素，其中，块级元素(display:block;)是指有确定的宽和高，独立占一行，而行内元素(display:inline;)是指元素能够在一行显示，没有宽度和高度；可置换元素是指占有宽高的行内元素(display:inline-block;)</p><br><hr><br><p>margin对于table及行内元素不起作用，对于行内不可替换元素只有margin-top和margin-bottom不起作用;</p><br><p>对于行内可置换元素padding,margin的各个方向均起作用，对于块级元素也是同样。同时还应该注意垂直外边距的合并问题，即10+15=15;</p>","categories":[],"tags":[]},{"title":"JS中的变量提升","url":"http://yoursite.com/2016/09/22/JS中的变量提升/","content":"<p></p><h2>JS变量提升</h2><p></p>\n<p></p><p>JS的变量提升是与C语言不同的,在C语言中，若在变量的定义前出现除定义变量的语句外的其他语句，通常会出现error,但是在JS中，会将你一个函数中所有的变量声明提升到该作用域的顶端，但是赋值语句还是在原来的位置。</p>\n","categories":[],"tags":[]},{"title":"关于php的一些问题","url":"http://yoursite.com/2016/09/21/关于php的一些问题/","content":"","categories":[],"tags":[]},{"title":"php内置处理函数","url":"http://yoursite.com/2016/09/21/php内置处理函数/","content":"<p>在这里，总结一下近期自己学过的一些php处理函数，按照处理函数处理的对象的不同来逐个说明。</p>\n<p><hr></p>\n<p></p><h2>变量</h2><br><strong>gettype()</strong><p></p>\n<p>参数是变量名，用来获取变量的类型。</p><br><strong>settype()</strong><br><p>参数是变量名及要设置的变量的数据类型。类型应该是单引号的字符串形式。</p><br><strong>isset()函数</strong><br><p>参数是变量名,检查变量是否存在，存在返回true.</p><br><p>这里的参数可以是一个变量或者是一个以逗号分隔的变量列表!</p><br><strong>unset()</strong><br><p>参数是变量名，用来销毁一个变量.</p><br><strong>empty()</strong><br><p>参数是变量名，检测一个变量是否存在，并且这个变量的值是否为0或空值，若是则返回true.</p><br><strong>intval(),floatval(),strval()</strong><br><p>可以根据函数名前面的名称判断将一个变量转化后的数据类型。其中将一个字符串传入intval()中，可以同时传递一个将此变量转化为整数的进制数。</p><br><h2>文件处理函数</h2><br><strong>fopen()</strong><br><p>用来打开文件，参数有2个，分别是文件指针文件模式，第两个参数必须是字符串形式,成功时返回一个文件指针</p><br><strong>fwrite()</strong><br><p>该函数用来写文件，它有3个参数，分别是文件指针，字符串变量或者字符串，字符串长度。</p><br><strong>fclose()</strong><br><p>用来关闭文件，参数是文件指针。关闭成功时返回true.</p><br><strong>feof()不再介绍</strong><br><strong>fgets()</strong><br><p>有两个参数，分别是文件指针和字符串长度，每次读取一行内容，遇到\\n或者EOF或者达到最大长度时结束。可以读取到的最大长度是指定长度-1.</p>\n","categories":[],"tags":[]},{"title":"php中数据的存储与检索","url":"http://yoursite.com/2016/09/20/php中数据的存储与检索/","content":"","categories":[],"tags":[]},{"title":"创建数据库","url":"http://yoursite.com/2016/09/20/创建数据库/","content":"<p></p><p>这几天在学习数据库，学习的可能不太深入，这里记录我在创建数据库中遇到的一些问题。</p><br>在学习了mysql必知必会以后，开始尝试创建数据库，但是好几次都会出现error,只是因为没有遵循完整性约束条件（在通过外键将两个表连接起来时，要保持外键的取值与所连的表的主键的取值范围相同，外键不能是它所在的表的主键）。<br><br><br><br>在创建用户以后，不能使用新建的用户登录phpmyadmin,可以通过查看用户看是否存在匿名用户，若存在，要消除匿名用户的影响可以通过删除匿名用户和为匿名用户增加密码来解决。<br>删除用户:DELETE FROM mysql.user WHERE user=’’;<br>         FLUSH PRIVILEGES;<br>设置密码:set password for ‘ ‘@loalhost=Password(‘密码’);<p></p>\n","categories":[],"tags":[]},{"title":"确定元素的尺寸","url":"http://yoursite.com/2016/09/06/确定元素的尺寸/","content":"<p></p><h2>clientWidth</h2><br>返回浏览器的宽度（内边距，不包含滚动条的宽度）<p></p>\n<p></p><h2>OffsetWidth</h2><br>返回元素的布局宽度（内边距，边界，滚动条的宽度）<p></p>\n<p></p><h2>scrollWidth</h2><br>返回元素的宽度，单位是px,包括内边距，不可见的部分，不包括边框，滚动条，外边距。<p></p>\n<p></p><h2>确定元素的位置</h2><br>offsetLeft:距离父元素左边的距离（相对位移）；<br>offsetTop:距离父元素上面的距离（相对位移）；<br>offsetParent:返回离自己最近的定位元素(父元素)，如果没有返回body.<br>offsetX：距离父元素内边界的X坐标。<p></p>\n","categories":[],"tags":[]},{"title":"html的meta及DOCTYPE","url":"http://yoursite.com/2016/08/31/html的meta及DOCTYPE/","content":"","categories":[],"tags":[]},{"title":"css选择器的优先级","url":"http://yoursite.com/2016/08/31/css选择器的优先级/","content":"<p></p><h1>css选择器</h1><p></p>\n<ol>\n<li><p>css的选择器有id选择器,类选择器,元素选择器,通配选择器,属性选择器。其中,类选择器可以使用多类选择器，即class值为两个已经定义的类名，且以两个已经存在的类名设置样式，表示class值为这两个类名时使用的样式，这两个类名之间用空格隔开。如:<br><code>&lt;a class=&quot;b c&quot;&gt;&lt;/a&gt;</code><br><code>.a{color:red;}</code><br><code>.b{font-size:20px;}</code><br><code>.a .b{font-family:&quot;雅黑&quot;;}</code><br>则上面的a标签有以上3种样式。</p>\n</li>\n<li><p>元素的style属性。</p>\n</li>\n<li><p>id选择符&gt;类选择符&gt;元素选择符</p>\n</li>\n<li><p>通配选择符。</p>\n</li>\n</ol>\n","categories":[],"tags":[]},{"title":"Ajax","url":"http://yoursite.com/2016/08/10/AJAX/","content":"<p></p><h2>简介</h2><br>AJAX（异步的JavaScript和XML）不是一种语言，而是一种使用现有标准的新方法，在不更新页面的情况下，实现和服务器交换数据并动态更新网页。它的核心是XHR对象。<p></p>\n<p></p><h2>XHR对象</h2><br><b>创建XHR对象</b><br>      var xhr=new XMLHttpRequest();<br>      XHR对象拥有2个方法，4个属性。以下将分别讲解。<br><b>方法</b><p></p>\n<ul>\n<li>open()<br>它接收3个参数,分别是请求方法，请求URL，是否异步处理。但是open()并不是真正发送请求，仅是启动一个请求以备发送。</li>\n<li>send()<br>它接收参数，即作为主体要发送的数据，没有要发送的数据时，为避免出错参数为null.<br><strong>属性</strong></li>\n<li>responseText<br>被返回的文本，无论返回的内容类型是什么，返回的文本都会存在这里。</li>\n<li>responseXML<br>当返回的文本内容类型为XML时，返回的文本将会保存在这里。</li>\n<li>status<br>响应的HTTP状态（HTTP状态代码为200时，表示响应成功;HTTP状态代码为304时，表示请求的资源没有改变。）</li>\n<li>statusText<br>HTTP状态说明<br><strong>是否异步处理</strong><br>当open()的第三个参数为false时，表示同步处理（js代码会等到服务器响应之后再继续执行），<br>收到响应后，响应内容被保存在XHR的属性中。<br>当open()的第三个参数为true时，表示异步处理（js代码继续执行，不用等待响应），此时应该检测readyState属性。<br>readyState的值和代表含义如下 :<br>0 —— 没有调用open();<br>1 —— 调用open(),没有调用send();<br>2 —— 调用send(),没有收到响<br>3 —— 已经接收到部分响应数据<br>4 —— 已经接收到全部的响应数据<br>当readyState的值改变时，会触发onreadystatechange事件。不过在调用open()之前指定onreadystatechange事件处理程序才能保证跨浏览器兼容性。<br><strong>取消异步处理</strong><br>可以通过调用abort()实现。<br><h2>HTTP头部信息</h2><br><strong>setRequestHeader()</strong><br>可以设置自定义的请求头部信息，接收两个参数,分别是：头部字段的名称，头部字段的值。在open()之后，send()之前调用它<br><strong>getResponseHeader()</strong><br>接收一个参数，即头部字段的名称，返回对应的头部字段的值。<br><strong>getAllResponseHeaders()</strong><br>返回包含所有头部信息的长字符串。<br><h2>请求方法</h2><br><strong>GET</strong><br>用于从服务器查询信息。可以将查询字符串置于URL的末尾。查询字符串每个参数的名称和值都必须是encodeURIComponent()进行编码。<br><strong>POST</strong><br>用于向服务器发送应该被保存的信息，post请求的主体可以包含非常多的数据，格式不限。post请求的第二步就是send()，send()的参数必须是xml文档,文档经序列化以后作为请求主体被提交到服务器。<br>但是,服务器对post请求和web表单请求不会一视同仁，我们就需要程序读取发送过来的数据，提取出有用的部分，可以用XHR模仿表单提交，将Content-Type的头部信息设为application/x-www-form-urlencoded,将表单信息序列化，再通过XHR发送到服务器。<br><h2>FormData类型</h2><br>FormData类型为序列化表单和创建于表单数据格式相同的数据提供了便利。<br><strong>创建FormData对象</strong><br>  var form=new FormData();<br>  form.append(“name”,”a”);<br>append()函数接收两个参数，分别是；对应表单字段的名字和字段中包含的值。<br>也可以向FormData()构造函数中传入表单元素。<br><h2>超时设定</h2><br>仅IE8支持，IE8改XHR对象添加了timeout属性，给timeout属性设置一个值,当响应时间超过这个值时，就会执行ontimeout事件<br><h2>overrideMIMEType()</h2><br>返回响应的MIME类型决定了XHR对象如何处理返回的文本，当MIME为text/plain,但实际上数据是XML，则responseText属性中是null.通过调用overrideMIMEType()可以设置MIME类型。参数是MIME类型<br><h2>进度事件</h2><br>一共有6个进度事件，只在这里讲述其中2个事件。</li>\n<li>load事件<br>当响应接收完毕后会触发load事件，用以替代onreadystatechange事件，而onload事件处理程序会接收到event对象，它的target属性会指向XHR对象实例，访问到它的所有属性和方法。</li>\n<li>progress事件<br>会在浏览器接收新数据期间周期性的触发，progress事件处理程序会接收event参数,它的target属性指向XHR对象，不过他还有3个额外的属性,分别是:lengthComputable(表示进度信息是否可用),totalSize(预期的字节数),position(已经接收到的字节数).<br><h2>跨源资源共享</h2><br><b>什么是跨域</b><br> <p>请求的url的协议，域名，端口三者任一与当前页面不同即为跨域。</p><br><strong>XDR</strong><br>IE8引入了XDR，与XHR类似，但能实现跨域通信，而XHR只能访问与他的页面位于同一域的资源。且cookie不随请求发送，不随响应返回，不能访问响应头部的信息，<br>只能修改请求头部的Content-Type字段,只支持get和post请求.且所有的XDR请求都是异步执行的。<br><strong>XDR对象的使用方法</strong><br>var xdr=new XDomainRequest();<br>xdr.onload=function(){<br>  alert(xdr.responseText);<br>}<br>xdr.open(“get”,”####”);<br>xdr.send(null);<br><strong>同样,XDR对象也支持timeout属性以及timeout事件处理程序</strong><br>为支持post请求,XDR对象也支持ContentType属性,用来表示发送数据的格式。<br>而其他浏览器只需要将open()中的第二个参数url设为绝对URL即可。跨域XHR同时存在一些限制（为了安全考虑），如；<br>1.不能使用setRequestHeader()设置自定义头部。<br>2.不能发送和调用cookie.<br>3.使用getAllRequestHeaders()返回空字符串。<br><strong>动态创建script标签</strong><br>img标签的src可以实现跨域，script的src也可以实现跨域。如:<br>  var script=document.createElement(“script”);<br>  script.src=”  “; //填写请求的url<br>  document.body.appendChild(script);<br><strong>带凭据的请求</strong><br>一般地，跨域请求不提供凭据(cookie,客户端SSL证明,HTTP认证)，但是通过withCredentials属性设为true,可以指定某个请求发送凭据。如果服务器接收这个请求就会用下面的HTTP头部来响应；Access-Control-Allow-Credentials:true.如果服务器的响应里没有包含这个头部，则浏览器不会把响应交给JS，responseText的值是空字符串。<br><strong>Jquery Ajax</strong><br>通过Jquery Ajax的JSONP实现跨域请求。</li>\n</ul>\n","categories":[],"tags":[]},{"title":"JSON","url":"http://yoursite.com/2016/08/09/JSON/","content":"<p></p><h2>简介</h2><br>JSON类似于XML，它是一种数据格式，用来结构化数据的方式，拥有与JS类似的语法。<p></p>\n<p></p><h2>语法</h2><br>JSON的值可以是布尔值，数值，字符串，null,数组，对象。其中布尔值，数值与在JS中的使用方法相同。其他的稍微有些不同。<br><strong>注意</strong><br>JSON不允许使用对象实例，变量和函数。<br><strong>字符串</strong><br>JS中的字符串可以使用单引号或者双引号，而JSON中的字符串必须使用双引号，否则会导致语法错误。<br><strong>数组</strong><br>不允许出现变量和分号。因为分号是JS的语法，而JSON不属于JS。<br><strong>对象</strong><br>JS中的对象的属性可以用双引号括起来也可以不用，而JSON中的对象的属性必须要用双引号括起来，在末尾不能出现分号，而且不允许变量出现。<p></p>\n<p></p><h2>JSON对象的方法</h2><br>JSON对象拥有2个方法:parse()和stringify().<br><strong>parse()</strong><br>它用于将传入的js对象转化为JSON代码，还可以接收第二个参数，这个参数为还原函数，还原函数的参数分别是属性名和属性值，还原函数可以对其对应的属性进行操作，返回对应的值，如果还原函数返回的值是undefined,则表示要从结果中删除这个属性。<br><strong>stringify()</strong><br>它用于将传入的JSON代码转化为JS对象，如果某个属性的值为函数,原型成员,undefined，则对应的属性就会被忽略，不出现在js对象中，返回的结果是有效的JSON数据类型的实例属性。它不保存空格和缩进。而且，这个函数还可以接收2个参数，<br>第一个参数可以是数组或者函数（序列化选项），第二个参数可以是字符串或者数字（字符串缩进）。<p></p>\n<ol>\n<li>若第一个参数是数组，则只返回数组中指定的属性。</li>\n<li>若第一个参数是函数，则这个函数接收2个参数，分别是属性名和属性值，属性名必须是字符串，如果属性值并非键值对的形式时，属性名可以是空字符串，如果属性值为undefined时，则对应的属性会被忽略。</li>\n<li>若第二个参数为数字时，则它表示每个级别缩进的空格数。</li>\n<li>若第二个参数是字符串时，表示每个级别用该字符串分隔。</li>\n</ol>\n","categories":[],"tags":[]},{"title":"XML","url":"http://yoursite.com/2016/08/04/XML/","content":"<p></p><h2>XML简介</h2><br>xml是一种扩展性的标记语言，用来存储和传输数据，没有预定义的标签，允许用户自定义标签，它没有任何作为，而且它是HTML的补充，并不能替换HTML。XML文档是一个纯文本文档，任何可以处理纯文本的软件都可以处理它。<p></p>\n<p></p><h2>XML用途</h2><br>XML简化数据传输和数据共享，使资源有用。还可以作为一些Internet语言的基础。<p></p>\n<p></p><h2>XML文档树</h2><br>XML文档包括XML声明和元素，元素之间的关系有父元素，子元素，同胞。所有元素都有内容和属性。XML声明中包含XML文档的版本及编码方式。而元素分为根元素和子元素，根元素是所有子元素的父元素。<p></p>\n<p></p><h2>XML语法</h2><p></p>\n<ol>\n<li>对大小写敏感。</li>\n<li>必须要有关闭标签。</li>\n<li>属性值要用双引号括起来。</li>\n<li>使用实例引用。XML中存在一些特殊符号，必须要用实例代替它。如:&lt;,+,’,””. </li>\n<li>与HTML不同，XML会保留空格。</li>\n<li>XML注释与HTML的注释语法完全相同。</li>\n<li>XML必须正确嵌套。</li>\n<li>使用LF存储换行。<br><h2>XML元素</h2><br>XML元素指的是开始标签和结束标签之间的内容，包括开始标签和结束标签。XML元素的命名规则有：</li>\n<li>名称是字母，数字，其他字符的组合。</li>\n<li>名称不能以数字或者标点符号开头。</li>\n<li>尽量别再名称里使用-,.和空格。</li>\n<li>名称不能以xml,Xml,XML开头<br>且XML元素是可以扩展的，可以在不中断应用程序进行扩展<br><h2>XML属性</h2><br>属性提供有关元素的额外信息。如:&lt;img src=”#”&gt;中的src属性。<br>属性不包含在数据部分。<br>属性值应该用引号括起来，允许单引号包含双引号，或者双引号包含单引号，在属性值中允许使用引用实例。<br>同时，属性和子元素可以提供相同的信息。<br>在这里，建议元数据(数据的数据)存储为属性，数据存储为元素，尽可能少的使用属性。<br><h2>XML验证</h2><br>形式良好的XML文档值的是拥有正确语法的XML文档。<br>合法的XML指的是通过DTD验证的XML文档，DTD是用来定义XML文档的结构。<br>可以通过DOCTYPE声明引用DTD文档来验证XML文档。<br><h2>XMLHttpRequest</h2><br>用来进行后台与服务器的数据交换。<br>通过它可以进行:<br>1.在不进行重新加载的情况下进行数据更新<br>2.可以向服务器发送数据<br>3.可以从服务器接收数据<br>4.可以向服务器请求数据<br><strong>创建XMLHttpRequest对象</strong><br>new XMLHttpRequest();<br><h2>XML解析器</h2><br>IE解析器可以提供XML文件解析和字符串解析。其他浏览器使用单独的解析器。<br>下面代码可以将XML文档解析到XML DOM中<br>&lt;script&gt;<br>if(window.XMLHttpRequest){<br> var xmltxt=new XMLHttpRequest();<br>}else{<br>  xmltxt=new ActiveXObject(“Microsoft.XMLHTTP”);<br>}<br>xmltxt.open(“GET”,url,false);<br>xmltxt.send();<br>var xmltet=xmltxt.responseXML;<br>&lt;/script&gt;<br>下面代码可以将xml字符串解析<br>if(window.DOMParser){<br> x=new DOMParser();<br> xmltxt=x.parseFromString(xml字符串,text/xml);<br>}else{<br> xmltxt=new ActiveXObject(“Microsoft XMLDOM”);<br> xmltxt.asyne=”false”;<br> xmltxt.loadXML(xml字符串);            //解析xml字符串<br>}<br><strong>这里的parseFromString( )接收2个参数，分别是字符串和内容类型，内容类型始终为text/xml,在发生解析错误时，仍然会返回一个Document类型，文档元素是&lt;parsererror&gt;内容是对解析错误的描述。<br>且DomParser只能解析格式良好的xml文档，因此他并不能解析html文档.</strong><br><h2>创建空的xml文档</h2><br>var xmldom=document.implementation.createDocument(参数1，参数2，参数3);参数具体为:<br>参数1是指定的命名空间，参数2是xml文档元素的标签,参数3是文档类型。这3个参数都为必选，因此，<br>尽管你不指定命名空间，也要将其设为空，当不指定文档类型时，将其设为null.<br><h2>将HTML文档解析为XML文档</h2><br>有两种方法：<br><strong>第一种</strong><br>首先，应该先创建XMLSerializer的实例，再调用serializeTostring()方法。<br><strong>第二种</strong><br>DOM中的每个节点都拥有xml属性，它返回指定节点的xml字符串。<br><h2>命名空间</h2><br>当两个xml文档一起被使用时，如果它们包含相同的元素名，则会发生命名冲突，而xml解析器不会解决这种错误。<br>解决它有两种方法：1.使用前缀的方法 2.使用命名空间<br><strong>前缀</strong><br>如:  &lt;table&gt;  可以写成  &lt;h:table&gt;<br><strong>使用命名空间</strong><br>即给开始标签设置xmlns属性，xmlns的使用方法如下:<br>xmlns:namespace=”###”;   这样就为某个前缀设置了与命名空间相关联的限定名称。（它的子元素要加前缀）<br>带有相同前缀的元素指向同一个命名空间。<br><strong>在使用默认命名空间时，可以省略前缀。</strong><br><h2>CDATA</h2><br>xml文档中的大部分数据都会被xml解析器解析(包括开始标签和结束标签之间的数据),只有CDATA部分的文本不会被解析。<br><strong>将xml作为CDATA的方法</strong><br>使用&lt;!–[CDATA[  作为CATAT部分的内容]]&gt;<br><strong>CDATA不允许嵌套，CDATA内容部分不允许出现]],结尾的]]&gt;不允许出现空格和换行。</strong><br><h2>注意事项</h2><br>xml可以嵌套在html文档中使用（这种用法称为数据岛）,用法是&lt;xml id=”” src=”##”&gt;id是用来标识xml数据岛，src是指向xml文档。不过这种用法只有IE支持。推荐使用js和xml DOM来解析xml文档。</li>\n</ol>\n","categories":[],"tags":[]},{"title":"js的内存管理","url":"http://yoursite.com/2016/08/03/js的内存管理/","content":"<p></p><h2>垃圾回收机制</h2><br>js不同于c,c++，拥有对内存的完全掌控，它的内存分配和回收都是自动的。<br>当一个对象不被其他对象引用时，就会被js里的垃圾回收机制自动清理。<p></p>\n<p></p><h2>垃圾回收的两种方法</h2><p></p>\n<p></p><h3>引用计数</h3><br>引用计数即当一个对象不被其他对象引用时，内存会被回收。但是它存在循环引用的问题（即两个对象相互引用时会出现内存泄露）<p></p>\n<p></p><h3>标记清除</h3><br>标记清除就是从全局环境出发，可以到达的对象都是必须存在的，而到达不了的对象是不需要的，它的内存会被回收。（这里不被需要的对象包括了引用计数里提到的不被引用的对象）<p></p>\n","categories":[],"tags":[]},{"title":"闭包的相关知识","url":"http://yoursite.com/2016/07/29/闭包的相关知识/","content":"<p></p><h2>闭包的定义</h2><br>闭包就是可以访问其他函数里的变量的一个函数。<p></p>\n<p></p><h2>创建闭包的方式</h2><br>常见的方式为:在一个函数里创建另一个函数。<br>即使闭包函数被返回，它仍然可以访问到外部函数的变量。<br>因为内部函数的作用域中包含了外部函数的作用域。<p></p>\n<p></p><h2>函数的执行过程</h2><br>在调用一个函数时，会创建一个执行环境和作用域链。<br>而在函数执行过程中，需要在作用域链中查找变量。每个函数都有一个变量对象。<br>全局环境的变量对象始终存在，而局部环境的而变量对象只在函数的执行过程中存在。<br>在创建一个内部函数时，会先创建一个包含全局环境的变量对象的作用域链，被保存在内部属性中，<br>当调用内部函数时，会为内部函数创建一个执行环境，通过复制刚才创建的全局变量对象的作用域链<br>构建执行环境的作用链。而作用域链就是指向变量对象的指针列表。一般来说，当内部函数执行完毕后，会销毁它的变量对象。而闭包有所不同。作用域链会被销毁，而变量对象仍然存在，只有当匿名函数被销毁后，匿名函数的外部函数的活动对象才会被销毁。因为匿名函数还在引用外部函数的变量。<p></p>\n<p></p><h2>闭包的2个特殊变量</h2><br>1.this:指函数的执行环境，在全局作用域中使用它，它指向window;当它作为一个对象的方法使用时，指向这个对象。<br>2.arguements:函数形参的参数数组;<br><strong>注意:this,arguments只能访问到其活动对象，不会访问到外部函数的这两个变量。</strong>如：<br>var name=”john”;<br>var obj={<br>     name:”mike”;<br>     getname:function(){<br>         return function(){<br>         return this.name;<br>     }<br>    }<br>}<br>//&nbsp;&nbsp;&nbsp;&nbsp;john;<p></p>\n<p></p><h2>闭包与变量</h2><br>在闭包中访问外部函数的变量时，只能访问到外部函数的变量的最终结果;要始终注意这点，否则结果会很出乎意料，这种情况在循环中出现最多。<p></p>\n<p></p><h2>模仿块级作用域</h2><br>在c,c++中存在块级作用域，而在js中不存在。但是使用闭包可以达到块级作用域的效果。<br>（function(){<br>//&nbsp;&nbsp;&nbsp;&nbsp;函数语句<br>}）();<br>第一个括号相当于函数表达式，第二个括号会立即执行这个函数。<p></p>\n<p></p><h2>内存泄漏</h2><br>如果闭包的作用域链中存在一个HTML元素，该元素就无法被销毁。<p></p>\n","categories":[],"tags":[]},{"title":"继承","url":"http://yoursite.com/2016/07/29/继承/","content":"<p><strong>上面说过可以通过原型链实现继承，不过在创建子类型的实例时，不能向超类型构造函数传递参数。<br>这里继续说明几种继承模式</strong></p>\n<p></p><h2>借用构造函数</h2><br>特点：在子类型构造函数的内部调用超类型构造函数，可以使用apply()或者call().<br>如：<br>function super(name){<br>    this.name=name;<br>}<br>function sub(){<br>    super.call(this,”john”);<br>    this.age=20;<br>}<br>这样就相当于在sub的每个实例中调用了super(),获得了在超类型构造函数中定义的属性和方法，<br>不过却不能进行函数复用；因此可以考虑使用以下继承的方法。<p></p>\n<p></p><h2>组合继承</h2><br>组合继承又称伪经典继承。是将原型链和构造函数组合到一起的一种继承方法<br>如：<br>function super(name){<br>    this.name=name;<br>    this.color=[“red”,”blue”];<br>}<br>super.prototype.sayname=function(){<br>    alert(this.name);<br>}<br>function sub(name,age){<br>    super.call(this,name);<br>    this.age=age;<br>}<br>sub.prototype=new super();<br>sub.prototype.constructor=sub;<br>sub.prototype.sayage=function(){<br>    alert(this.age);<br>}<br>这样通过在原型上定义函数就可以提高函数的复用。不过这种方法使用了两次超类型构造函数。<p></p>\n<p></p><h2>原型式继承</h2><br>特点:基于已有对象创建新对象，还不用创建自定义类型。如:<br> function object(o){<br>    function F();<br>    F.prototype=o;<br>    return new F();<br> }<br> ES5用Object.create()规范了原型式继承，接收两个参数，分别是：原型对象，为新对象定义额外属性的对象<p></p>\n<p></p><h2>寄生式继承</h2>（承接上面的object函数）<br> 与寄生构造函数和工厂模式类似，是一个封装继承过程的函数。<br> function create(o){<br>      var clone=object(o);<br>      clone.sayhi=function(){<br>      alery(“hi”);<br>  }<br>    return clone;<br> }<br> 但是它不能实现函数复用。<p></p>\n<p></p><h2>寄生组合式继承</h2><br>function super(name){<br>    this.name=name;<br>}<br>super.prototype.sayhi=function(){<br>    alert(“hi”);<br>}<br>function sub(name,age){<br>    super.call(this,name);<br>    this.age=age;<br>}<br>sub.portotype=object(super.portotype);<br>sub.prototype.constructor=sub;<br>这种方法是人们普遍接受的方法。<p></p>\n","categories":[],"tags":[]},{"title":"原型链之深入理解","url":"http://yoursite.com/2016/07/24/原型链之深入理解/","content":"<p><strong>原型链的原理</strong><br> 原型链实际上就是将一个原型对象用一个新类型的实例重写，重复多次，得到的每个原型之间的指向关系。<br><strong>原型链的作用</strong><br> 可以通过原型链实现继承，在搜索某个实例的方法时，顺着原型链一次向上查找，知道原型链的末端。<br><strong>为了深入理解原型链,我在这里举一个例子</strong><br>function Super(){<br>    this.color=[“red”,”blue”];<br>}<br>Super.prototype.getvalue=function(){<br>    return this.prototype;<br>}<br>function Sub(){<br>    this.sub=false;<br>}<br>Sub.prototype=new Super();<br>Sub.prototype.getsubvalue=function(){<br>    return this.sub;<br>}<br>  上面，将Sub.prototype作为Super的实例，让Sub.protototype继承了来自Super的属性和方法，<br>  同时由于重写了Sub.prototype,使Sub.prototype指向了Super的原型。<br>  <strong>注意，给原型对象(新类型的实例)重新定义某种方法或者添加方法时，必须在原型替换以后。</strong></p>\n","categories":[],"tags":[]},{"title":"自定义类型的几种模式","url":"http://yoursite.com/2016/07/24/自定义类型的几种模式/","content":"<p>自定义类型的几种模式有:工厂模式(寄生构造函数模式)，组合使用原型模式和构造函数模式，动态原型模式，稳妥构造函数模式。<br>这里在介绍几种模式之前，先介绍原型模式。<br>用原生构造函数创建对象，产生的每个实例的引用都不同。这样就会占用大量的内存空间。而这几种模式<br>都很好的解决了这个问题。</p>\n<p></p><h2>原型模式</h2><br> 原型模式其实就是多个实例共享原型保存的实例和方法。<br> 在利用原型模式前，应该先创建一个空函数，这个函数产生一个原型属性，这个属性是一个指针，指向原型对象。<br> 利用创建原型对象的属性和方法可以使得实例同样拥有相同的属性和方法。在原型对象上的改变都可以反应到实例上。<br>而原型对象的创建需要利用函数的prototype.如:<hr><p></p>\n<pre><code>  function Person(){};\n//创建一个函数\n  person.prototype.name=&quot;john&quot;;\n  person.prototype.age=20;\n  person.prototype.sayname=function(){\n    alert(this.name);\n  } \n  var person1=new Person();\n  var person2=new Person();\n</code></pre><p>   这样 person1,person2就拥有相同的属性和方法，即都有age，name属性和sayname方法。</p>\n<ul>\n<li>理解原型对象，构造函数和实例之间的的关系。<br>  构造函数的prototype指向原型对象，原型对象的constructor指向构造函数。实例的prototype指向原型对象。<br>这里原型对象的改变都会反应到实例上，而实例的改变一般不会影响到原型对象，只有当实例修改的属性是<br>一个引用类型时，实例的改变会影响到原型对象的改变。</li>\n<li><p>注意当给原型对象用对象字面量的方法添加方法和属性时，会修改原型对象的constructor属性。即constructor不再指向构造函数。<br>修改constructor属性时，可以再原型对象中修改，但是修改会改变Enumerable属性,使之从false变成true.可以用defineProperty()修改Enumerable属性。<br>defineProperty()接收3个参数，分别是对象，修改的属性（字符串形式），修改的的内容（函数形式）。<br></p><h2>组合使用构造函数模式和原型模式</h2><br>这种方法集二者所长，还可以传递参数。如：<p></p>\n<pre><code>function Person(age,name){\n    this.age=age;\n    this.name=name; \n}\nPerson.prototype=function(){\n    constructor:Person;\n    sayname=function(){\n        alert(this.name);\n    }\n}\n</code></pre><p>实例属性都是在函数中定义的，而所有实例共享的属性和方法都是在原型中定义的。修改在函数中定义的<br>所有属性都不会影响到其他的实例和原型对象。<br></p><h2>动态原型模式</h2><br>  把所有信息都封装在构造函数中，通过判断某个应该存在的方法是否有效，来决定初始化原型。<br>  而初始化原型只在初次调用构造函数时执行。<br>  如:<p></p>\n<pre><code>    function Person(age,name){\n    //属性\n      this.name=name;\n      this.age=age;\n    //方法\n      if(typeof this.sayname!=&quot;function&quot;){\n      this.sayname=function(){\n      alert(this.name);\n      }\n  }\n}\n</code></pre><p></p><h2>寄生构造函数模式</h2><br> 寄生构造函数模式和工厂模式相同，创建一个函数，此函数的作用是封装对象的代码，返回一个对象。如:<p></p>\n<pre><code>  function Person=function(age,name){\n     var o=new Object();\n     o.name=name;\n     o.age=age;\n     a.sayname=function(){\n           alert(this.name);\n }\n     return o;\n}\n</code></pre><p></p><h2>稳妥构造函数模式</h2><br>稳妥构造函数模式主要用于防止数据被其他程序修改，和在一些安全环境中使用。<br>与构造函数模式相同，但是有2点不同：不使用this,不使用new操作符调用构造函数。如：<p></p>\n<pre><code>    function Person(age,name){\n    //创建返回的对象\n    var o=new Object;\n    //在这里定义私有变量和函数\n\n    //添加方法\n    o.sayname=function(){\n        alert(name);\n    }\n    return o;\n}\n</code></pre></li>\n<li>注意，除了sayname方法外，没有其他方法访问数据成员。</li>\n</ul>\n","categories":[],"tags":[]},{"title":"如何获取html元素的css样式","url":"http://yoursite.com/2016/07/22/如何获取html元素的css样式/","content":"<p></p><h2>获取html节点的方式</h2><p></p>\n<ul>\n<li><code>document.getElementById(&quot;#&quot;)</code> &nbsp;&nbsp;&nbsp;&nbsp;<br>//获取id为#的节点</li>\n<li><code>document.getElementsByTagName(&quot;#&quot;)</code> &nbsp;&nbsp;&nbsp;&nbsp;<br>//获取html标签为#的所有节点</li>\n<li><code>document.getElementsByClassName(&quot;#&quot;)</code> &nbsp;&nbsp;&nbsp;&nbsp;<br>//获取类名为#的所有节点</li>\n<li>如果获取的是所有节点，可以通过偏移量获得具体的节点<br><code>如：var a=document.getElementsByTagName(&quot;#&quot;)[0];</code><br>//获取第一个标签名为#的节点<br><h2>获取html元素的css样式的方法</h2><br><b>element.style</b><br>通过上述方法可以获取到html节点，可以用节点名的style修改css样式，如果是使用的是外联样式表，<br>则会在内嵌样式上显示操作的样式。<br>如: (接上面的例子)<br><code>a.style.color=&quot;red&quot;;</code><br>这样a的文字颜色就会变成red.<br><b>getcomputedStyle()</b><ul>\n<li>注意：这种方式只能读，不能写。即不能改变元素的css样式<br><code>document.defaultView.getComputedStyle()</code><br>接收2个元素，分别是：计算元素的样式，伪元素字符串。若不需要伪元素字符串，第二个参数是null.</li>\n</ul>\n</li>\n</ul>\n","categories":[],"tags":[]},{"title":"正则表达式","url":"http://yoursite.com/2016/07/20/正则表达式/","content":"<ul>\n<li><h2>正则表达式是用来进行文本匹配的工具。</h2></li>\n<li><h2>正则表达式的匹配模式支持下列3个标志：</h2><br>   &nbsp;&nbsp;&nbsp;&nbsp;1.g:表示全局模式。应用于所有字符串。<br>   &nbsp;&nbsp;&nbsp;&nbsp;2.i:表示不区分大小写。<br>   &nbsp;&nbsp;&nbsp;&nbsp;3.m:表示多行模式。在达到文本末尾时，还会继续查找下一行中是否存在与模式匹配的项。</li>\n<li><h2>正则表达式常用的元字符</h2><br>  &nbsp;&nbsp;&nbsp;&nbsp;1.\\b:代表单词的开头或末尾，只匹配一个位置。<br>  &nbsp;&nbsp;&nbsp;&nbsp;2.\\d:匹配一个数字。<br>  &nbsp;&nbsp;&nbsp;&nbsp;3..:匹配换行符以外的任意字符<br>  &nbsp;&nbsp;&nbsp;&nbsp;4.*：重复次数，至少0次<br>  &nbsp;&nbsp;&nbsp;&nbsp;5.+：重复次数，至少1次<br>  &nbsp;&nbsp;&nbsp;&nbsp;6.? 表示匹配0次或者1次<br>  &nbsp;&nbsp;&nbsp;&nbsp;7.\\s:匹配任何不可见的字符（制表符，换页符）<br>  &nbsp;&nbsp;&nbsp;&nbsp;8.\\w:匹配任何非单词的字符（字母，数字，_）<br>  &nbsp;&nbsp;&nbsp;&nbsp;9.^:字符串的开头<br>  &nbsp;&nbsp;&nbsp;&nbsp;10.$：字符串的结束<br>  &nbsp;&nbsp;&nbsp;&nbsp;11.{n,m}:(n&lt;=m) 最少n次，最多m次<br>  &nbsp;&nbsp;&nbsp;&nbsp;12.[n-m]:匹配指定范围内的任意字符<br> &nbsp;&nbsp;&nbsp;&nbsp;13.（）: 用来将复杂的正则表达式分解为多个简单的子表达式。</li>\n<li><b>注意：模式中所有使用的元字符都必须转义，在[]中元字符可以不用转义；</b></li>\n<li><h2>定义正则表达式</h2><br>定义正则表达式有2中方法，分别是：字面量形式，RegExp构造函数<br>两者的区别是：正则表达式字面量会共享同一个实例，而用RegExp构造的每一个实例都是一个新实例。如：<br>字面量形式<pre><code>var a=/.at/g;    //匹配所有的以at结尾的3字符的字符串\n</code></pre>RegExp构造函数<pre><code>var b=new RegExp(&quot;.at&quot;,&quot;g&quot;)\n</code></pre>   a和b是完全等价的，使用RegExp构造函数定义正则表达式，接收2个参数，这两个参数必须是字符串形式，<br>   且2个参数分别是：匹配的模式，匹配模式的标志。而在字面量中转义的元字符必须在RegExp构造函数中<br>   双重转义。</li>\n<li><h2>RegExp实例属性</h2><br>每个实例都会具有以下属性，通过他们可以获得正则表达式的相关信息<br>  1.global：布尔值，正则表达式是否设定了g标志<br>  2.ignoreCase:布尔值，正则表达式是否设定了i标志<br>  3.multiline:布尔值，正则表达式是否设定了m标志<br>  4.source: 返回正则表达式的字符串表示。按照字面量的形式返回。<br>  5.lastIndex:整数，表示搜索下一个匹配项的字符位置，从0算起</li>\n<li><h2>RegExp实例方法</h2><br>1.<b>exec():</b> 接收1个参数，它是应用模式的字符串。返回的是一个数组，数组的第一项是与模式匹配的项，<br>其他的是与捕获组匹配的字符串。这个数组具有2个属性，分别是:index(匹配项在数组中的位置)，input<br>(应用正则表达式的字符串)。如果匹配模式是全局模式，则每次在字符串数组中继续查找匹配项，且lastIndex每次都不同<br>若没有全局标志，则每次返回第一个匹配项的信息。且lastIndex每次为0.<br>2.<b>test():</b>接收一个参数，它是应用匹配模式的字符串。若字符串与模式匹配返回true，否则返回false.<br>3.<b>toLocalString(),toString():</b> 返回正则表达式的字面量。与定义正则表达式的方式无关。<br>4.<b>valueOf():</b>返回正则表达式本身。</li>\n<li><p></p><h2>RegExp构造函数属性</h2><br>可以通过两种方法访问这些属性，即常属性法和短属性法。短属性法除了input外其他都不符合ES的标识符，<br>可以通过[]来访问.<br>  1.input($_):返回最近一次应用于匹配模式的字符串<br>  2.lastMatch($&amp;):最近一次的匹配项<br>  3.lastParen($+):最近一次的捕获组<br>  4.leftContent($`):input字符串中lastMatch之前的文本<br>  5.rightContent($’):input字符串中lastMatch之后的文本<br>  6.multiline($*):布尔值，所有表达式是否是否使用多行模式<br>  此外，还具有9个用于存储捕获组的属性，即RegExp.$1,RegExp.$2…<br>  <b>$1和\\1表示匹配的第一个正则子表达式，常用在回溯引用中。</b><p></p>\n <hr>\n</li>\n<li><p></p><h2>前后查找</h2><br>  <b>作用：前后查找都可以做到根据一个条件来筛选出一段文本，但筛选出的文本中不包含筛选条件。</b><br>  向前查找<p></p>\n<pre><code>任何表达式都可以转化为向前查找表达式，只需要在它之前加上?=前缀即可。\n</code></pre><p>  向后查找</p>\n<pre><code>向后查找表达式只需要加上?&lt;=前缀即可。\n</code></pre><p>  负向前查找</p>\n<pre><code>负向前查找是匹配不与指定模式相匹配的文本。类似于向前查找。应该使用?!前缀。\n</code></pre><p>  负向后查找</p>\n<pre><code>负向后查找类似于向后查找，匹配不与给定模式相匹配的文本。应该使用?&lt;!前缀。\n</code></pre><p>  <b>在前后查找表达式中，如果根据元字符进行前后查找，则该元字符需要转义。前后查找一般与()配合使用。</b></p>\n</li>\n<li><h2>贪婪型和懒惰型</h2><br>   <b>在正则表达式中，存在贪婪型和懒惰型两种方式，我们可以根据自身需求选择性使用</b><br>  以下例子均使用<br>   <code>var str=&quot;&lt;h1&gt;hello world!&lt;/h1&gt;&lt;h1&gt;Do you want to go shopping.&lt;/h1&gt;&quot;</code><br>   <code>var pattern=&quot;&lt;h1&gt;.*&lt;/h1&gt;&quot;</code><br>  贪婪型<pre><code>得到的结果是 &quot;&lt;h1&gt;hello world!&lt;/h1&gt;&lt;h1&gt;Do you want to go shopping.&lt;/h1&gt;&quot;\n</code></pre>  懒惰型<pre><code>得到的结果是 &quot;&lt;h1&gt;hello world!&lt;/h1&gt;&quot;\n</code></pre> 如何将贪婪型改为懒惰型<pre><code>只需要将 &quot;var pattern=&apos;&lt;h1&gt;.*&lt;/h1&gt;&apos;  改为 &apos;&lt;h1&gt;.*?&lt;/h1&gt;&apos;&quot;\n</code></pre>  <b>总结: 其实实现正则表达式匹配指定字符很简单，困难的是我们需要筛选出那些不需要的字符，所以在使用正则表达式时一定要考虑周到。</b>  <hr>\n</li>\n</ul>\n","categories":[],"tags":[]},{"title":"JS的引用类型及其方法","url":"http://yoursite.com/2016/07/20/JS的引用类型及其方法-1/","content":"<p></p><h1>引用类型</h1><p></p>\n<p></p><h2>概念</h2><br>引用类型指的是由多个变量组成的对象。javascript不允许访问对象的内存空间。<br> 当复制引用类型值的时候将变量的地址复制给新的变量，它们指向的是堆中的相同空间。<br> <hr><br> <h2>常见的引用类型</h2><br>  <strong>Object类型</strong><p></p>\n<ol>\n<li>定义<br>定两种义有2种方法：1.new + object 构造函数 2.对象字面量的方法<ul>\n<li>new + object 构造函数<br>如：<br><code>var myobject=new object();</code><br><code>myobject.age=10;</code><br><code>myobject.name=&quot;john&quot;;</code></li>\n<li>对象字面量的方法<br>var myobject={<br>  name:”john”;<br>  age:10;<br> };<br>以上两种方法建立的myobject相同。</li>\n</ul>\n<ol>\n<li>访问object的属性<ul>\n<li>点表示法<br><code>alert(myobject.name);</code>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//john</li>\n<li>使用方括号<br><code>alert(myobject[&quot;name&quot;]);</code>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//john</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>Array类型</strong><br>   1.定义<br>    定义有2种方法：<br>      1.构造函数   2.数组字面量表示法</p>\n<ul>\n<li>构造函数<pre><code>`var myArray=new Array();`\n其中，可以向构造函数里面传递数组长度，也可以传递数组元素。\n</code></pre></li>\n<li>数组字面量表示法<pre><code>var myArray=[]   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//创建一个空数组\n可以向[]里面放入数组元素，不过数组元素需要字符串表示.每个数组都有length属性\n</code></pre>  2.检测数组<pre><code>通过Array.isArray()方法检测数组    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//确定是不是数组\n</code></pre>  3.方法</li>\n<li>转换方法<pre><code>1.每个对象都有tostring(),tolocalstring(),valueof()方法。\n  tostring():&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;返回以逗号分隔的数组元素的字符串表示，\n  valueof()和tolocalstring()与它相同。\n2.join()方法:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;接收一个参数，这个参数为数组元素的分隔符。\n</code></pre></li>\n<li>栈方法<pre><code>push():&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;接收任意多个参数，在数组末尾添加任意多项。\n返回数组的长度\n</code></pre></li>\n<li>队列方法<pre><code>shift():&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;删除数组的第一项，并返回该项的值。\nunshift():&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;接收任意多个参数，在数组的开头添加任意多项，\n返回数组的长度。\n</code></pre></li>\n<li>重排序方法<pre><code>reverse():&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;反转数组项的顺序\nsort():&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;默认情况下按升序排列，但是可以接收比较函数。\n比较函数&amp;nbsp;&amp;nbsp;&amp;nbsp;如果第一个值位于第二个值的前面返回一个负数，\n相等返回0，反之返回一个正数。\n</code></pre></li>\n<li>操作方法<pre><code>concat():&amp;nbsp;&amp;nbsp;&amp;nbsp;接收任意多个参数，创建一个新数组，该数组为原来数组的的副本。\n将参数里的元素逐个添加到数组末尾。并返回新数组。\nslice():&amp;nbsp;&amp;nbsp;&amp;nbsp;接收一个或两个参数。第一个参数为起始位置，第二个参数为结束位置。\n当只有一个参数时，默认为从起始位置到数组结束。返回新数组。\nsplice():&amp;nbsp;&amp;nbsp;&amp;nbsp;接收2-3个参数。第一个参数为起始位置，第二个参数为数组的项数，\n第三个参数为要添加给数组的字符串。\n</code></pre></li>\n<li>位置方法<pre><code>indexOf()和lastIndexOf()都返回查找的项在数组中的起始位置。\n可接收2个参数，分别是 查找的项和起始位置。indexOf()从数组开始查找，lastIndexOf()从数组末尾查找。\n</code></pre>-迭代方法<pre><code>every:&amp;nbsp;&amp;nbsp;&amp;nbsp;对数组的每一项运行函数，当数组的每一项都返回true时，返回ture;\nforEach():&amp;nbsp;&amp;nbsp;&amp;nbsp;对数组的每一项运行函数，无返回值。\nmap():&amp;nbsp;&amp;nbsp;&amp;nbsp;对数组的每一项运行函数，返回数组每项运行的结果组成的数组\nsome():&amp;nbsp;&amp;nbsp;&amp;nbsp;对数组的每一项运行函数，当某一项返回true时，返回值是true\nfilter():&amp;nbsp;&amp;nbsp;&amp;nbsp;对数组的每一项运行函数，返回返回值为true的项组成的数组\n</code></pre></li>\n<li>归并方法<pre><code>reduce(),reduceRight():&amp;nbsp;&amp;nbsp;&amp;nbsp;可接收4个参数，分别是：前一个值，\n当前值，项的索引和数组对象。\nreduce()从数组开头开始，第一项与第二项运行函数的返回值充当前一个值，再与数组的第三项运行函数...\nreduceRight()只是从数组尾部开始运行函数。\n&lt;hr /&gt;\n</code></pre><h2>function类型</h2><br>   1.定义<pre><code>函数定义有3种方法：分别是函数表达式，构造函数和 function name(){};\n</code></pre></li>\n<li>function name    <pre><code>function fun(){\n      return 0;\n}\n</code></pre></li>\n<li>函数表达式<pre><code>var sum=function(a,b)\n</code></pre></li>\n<li>构造函数<pre><code>var sum=new function(&quot;#&quot;,&quot;#&quot;,...)\n    **function构造函数可以接受任意多个参数，但是最后一个参数必须是函数体**\n</code></pre>  2.函数重载<pre><code>当同一个函数名定义了两个不同的函数体时，只对第二个函数体有效。因为第二个覆盖了第一个\n</code></pre>  3.函数声明和函数表达式<pre><code>在执行代码之前，解析器进行函数声明，javascript引擎第一遍会声明函数并将函数声明添加到执行环境中，\n将函数声明置于源代码树的顶部。\n如果用函数表达式法或构造函数法定义函数，则函数调用可置于函数声明之前。若为函数表达式，\n则调用必须在声明之后。因为函数表达式当执行到它的代码行，它才会真正解析执行。\n</code></pre>  4.函数的内部属性<pre><code>- arguement.callee :&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\n消除内部耦合,内部耦合即将递归函数名赋给一个变量a，将递归函数改变后，调用a它的函数值会改变\n- this :&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;引用函数的环境对象，\n当在全局作用域执行函数时，this引用window。\n- caller :&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;调用当前函数的引用。\n在全局作用域调用当前函数，它的值为NULL.\n</code></pre>  5.函数的属性及方法<ul>\n<li>属性<br>length :&nbsp;&nbsp;&nbsp;表示接收的参数个数<br>prototype :&nbsp;&nbsp;&nbsp;所有实例方法的真正所在。不可枚举。</li>\n<li>方法<br>apply() :&nbsp;&nbsp;&nbsp;在特定的作用域调用函数，接收2个参数,<pre><code>分别是:函数的作用域，参数数组(arguement对象)。\n</code></pre>call() ：&nbsp;&nbsp;&nbsp;与apply()相同，不过接收参数的方式不同，将参数逐个列举出来。<br>bind() :&nbsp;&nbsp;&nbsp;创建函数实例，将this值绑定到传入的参数上。 </li>\n</ul>\n</li>\n</ul>\n<p></p><h2>Number类型</h2><p></p>\n<ul>\n<li>toFixed() :&nbsp;&nbsp;&nbsp;接收一个数值参数，返回数字的指定小数位数的字符串表示。</li>\n<li>toString(),toLocalString() :&nbsp;&nbsp;&nbsp;返回字符串形式的数值。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中toString()可接收一个参数，它表示转化的基数。</li>\n<li>valueof()&nbsp;&nbsp;&nbsp;返回对象表示的基本类型的数值。</li>\n<li>toExponential() :&nbsp;&nbsp;&nbsp;返回指数表示。</li>\n<li>toPrecision() :&nbsp;&nbsp;&nbsp;返回数字的合适表示，可以是toFixed(),<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以是toExponential().<h2>Boolean类型</h2></li>\n<li>Boolean类型是与布尔值相对应的引用类型。布尔表达式中的所有对象都会被转化为true.</li>\n<li>type对引用类型返回object,instanceof对引用类型返回true.<h2>String类型</h2></li>\n<li>字符方法<br>charAt :&nbsp;&nbsp;&nbsp;接收一个参数，即基于0的位置，返回该位置的字符。<br>charCodeAt :&nbsp;&nbsp;&nbsp;与charAt()相同，返回该位置的字符的字符编码。</li>\n<li>字符串操作方法<br> 1.concat() :&nbsp;&nbsp;&nbsp;上面已经描述过，不再赘述.<br> 2.sclice() :&nbsp;&nbsp;&nbsp;上面已经描述过，不再赘述.<br> 3.substr() :&nbsp;&nbsp;&amp;nbsp；可以接收1-2个参数，分别是:&nbsp;&nbsp;&nbsp;起始位置，<br> 返回字符的个数。返回值是一个字符串或者一个字符。它会将第一个负值参数加上字符串长度<br> 得到一个正值，将第二个负值参数转化为0.<br> 4.substring() :&nbsp;&nbsp;&nbsp;接收1-2个参数，分别是:&nbsp;&nbsp;&nbsp;起始位置，<br> 结束位置。返回值是一个字符或字符串。它会把所有负值转化为0.</li>\n<li>字符位置方法<br> indexOf(),lastIndexOf() :&nbsp;&nbsp;&nbsp;上面已经描述过，不再赘述.</li>\n<li>trim()方法<br> 创建一个字符串的副本，删除字符串的前缀和后缀的所有空格，返回得到的字符串。</li>\n<li>字符串大小写转化<br>  1.toLowerCase() :&nbsp;&nbsp;&nbsp;将所有字符转化为小写。<br>  2.toUpperCase() :&nbsp;&nbsp;&nbsp;将所有字符转化为大写。<br>  3.toLocalLowerCase(),toLocalUppercase():与上述两个作用相同，只是针对特定地区实现。</li>\n<li>字符串模式匹配<br> 1.match() :&nbsp;&nbsp;&nbsp;接收一个参数，要么是正则表达式，要么是RegExp对象。返回一个数组。<br> 2.search() :&nbsp;&nbsp;&nbsp;接收参数与match()相同。返回字符串中第一个匹配项的索引。<br> 没有找到匹配项返回-1.<br> 3.replace() :&nbsp;&nbsp;&nbsp;接收2个参数。分别是 : 字符串(RegExp对象)和函数(字符串)。<br> 如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有的字符串，就是将第一个<br> 参数设为正则表达式，且指定全局标志(g).<br> 4.localCompare() :&nbsp;&nbsp;&nbsp;比较两个字符串的大小。返回0，-1或1.<br> 5.fromCharCode() : 接收任意多个参数，它们是字符编码，返回与之对应的字符串。<br><strong>Date</strong><br><strong>Exe</strong></li>\n</ul>\n","categories":[],"tags":[]},{"title":"用github pages和hexo搭建博客","url":"http://yoursite.com/2016/07/19/用github-pages和hexo搭建博客/","content":"<p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"external\">安装Git</a><br><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">安装Node.js</a></p>\n<p></p><h2>搭建博客有两种方法:</h2><br><em>1. 使用username.github.io</em><br><em>2. 使用项目仓库</em><br><strong>注意:项目仓库允许有多个，但是username.github.io只允许有一个;并且hexo只上传他的public文件</strong><p></p>\n<h2 id=\"注册及创建仓库\"><a href=\"#注册及创建仓库\" class=\"headerlink\" title=\"注册及创建仓库\"></a>注册及创建仓库</h2><p><em>注册这里就不再说明</em><br>      <strong>1. 使用username.github.io名建立仓库</strong><br>       添加一个名为username.github.io的仓库，进入仓库后设置settings,按下launch automatic page generator–&gt;设置–&gt;continue to layouts–&gt;选择主题.<br>      <strong>2. 创建项目仓库</strong><br>       此种方法创建仓库和以上方法类似，只不过将仓库名设为其他。之后创建另一个分支gp-pages,设置settings.<br>     <strong>3. 打开Git</strong></p>\n<pre><code>1. 创建.git\n   mkdir name    //创建目录\n   git init  \n2. 登录Git:  \ngit config --global user.name &quot;###&quot; \n //这里的名字不是github的昵称，是你的真实名字\ngit config  --global user.email &quot;###&quot;\n  //注册git时的邮箱\n3. 设置SSH\n   在Git Bash中输入ssh-keygen,一路回车则可以生成ssh,\n   将生成的ssh粘贴复制到settings里的ssh。\n4. 检测ssh是否设置成功\n   ssh-T git@github  \n5. 采用username.github.io创建仓库时，在本地的git bash上把这个仓库复制下来\n        git clone git@github.com:username/repository name                \n   如果要推送东西的话依次用git add,git commit -m &quot; &quot;,git push命令(首先要切换到你想要的目录)\n   如果是项目仓库的话同时需要这步。\n6. 在git bash上输入 npm install -g hexo  (安装hexo)\n</code></pre><p><br></p>\n<p></p><h2>安装hexo及命令</h2><br>   <strong>主要命令</strong><p></p>\n<ol>\n<li>hexo s  —- 在本地预览网页 </li>\n<li>hexo g   —- 生成网页</li>\n<li>hexo deploy (hexo d)  —- 部署.deploy目录</li>\n<li>hexo new —–新建文章</li>\n<li>hexo new page —- 新建页面</li>\n</ol>\n<hr>\n<p>   <strong>步骤</strong><br>     在本地创建一个Hexo文件夹，鼠标右键选择Git Bash,依次输入命令：</p>\n<pre><code>1. hexo init    创建网站所需的所有文件\n2. hexo g    \n3. hexo s\n4. 在浏览器地址栏输入localhost:4000  查看hexo博客\n5. 将hexo 和 github pages连接起来: \n修改Hexo文件夹下面的_config文件：\n如果用第一种方法创建的仓库的话，将deploy的branch设为master,否则设为gh-pages;\n同时将deploy的repo设为仓库的SSH路径。\n在Hexo的Git Bash上输入下面命令\n`npm install hexo-deployer-git --save`    //安装一个包\n6. 上传到github上面\nhexo clean  清除缓存\nhexo g\nhexo d      //部署.deploy目录\n7. 还可以clone别人的主题\n如：`git clone https://github.com/wuchong/jacman.git themes/jacman`  \n更新主题时: \n   `cd themes/jacman`\n   `git pull`\n   将Hexo文件里的_config的theme设为你想要的主题\n</code></pre>","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"<p>project:</p>\n<ul>\n<li>type: association<br>name: Sign in<br>url: <a href=\"https://github.com/2241980117m/project/tree/master/%E7%AD%BE%E5%88%B0\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/project/tree/master/%E7%AD%BE%E5%88%B0</a><br>intro: Boostrap and php</li>\n<li>type: association<br>name: H3C SignUp<br>url: <a href=\"https://github.com/2241980117m/project/tree/master/huasanbei\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/project/tree/master/huasanbei</a><br>intro: Collaboration</li>\n<li>type: association<br>name: web-page competition<br>url: <a href=\"https://github.com/2241980117m/web-page-competition\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/web-page-competition</a><br>intro: 使用七牛作为存储空间。主要完成了作品上传、展示，及倒计时页面</li>\n<li>type: update<br>name: Sign in and say<br>url: <a href=\"https://github.com/2241980117m/project/tree/master/Sign\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/project/tree/master/Sign</a><br>intro: 在原来签到的基础上，完成了留言、数据库的改进</li>\n<li>type: update<br>name: Sign in and say<br>url: <a href=\"https://github.com/2241980117m/project/tree/master/Sign\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/project/tree/master/Sign</a><br>intro: 在原来签到的基础上，完成了留言、数据库的改进</li>\n<li>type: join<br>name: 算法和网络协议仿真<br>url: <a href=\"http://pro.mperson.club/open/\" target=\"_blank\" rel=\"external\">http://pro.mperson.club/open/</a><br>intro: 实现了算法的动态演示、生成随机数、速度调节、升降序等功能。</li>\n<li>type: personal<br>name: 机考-面试系统<br>url: <a href=\"https://github.com/2241980117m/testSys\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/testSys</a><br>intro: 采用web worker实现倒计时，localStorage存储答案和题目信息，websocket实现实时将面试状态发送给前端。</li>\n<li>type: personal<br>name: 机器人聊天系统<br>url: <a href=\"https://github.com/2241980117m/vueItem\" target=\"_blank\" rel=\"external\">https://github.com/2241980117m/vueItem</a><br>intro: 仿QQ试下聊天和修改信息等功能。vuex,vue-router实现的单页面应用，采用webpack打包。后端用nodejs操作图灵机器人接口实现和机器人通信。</li>\n</ul>\n","categories":[],"tags":[]}]